<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ardpicprog: Serial protocol for programming PIC&#39;s and EEPROM&#39;s with Arduino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ardpicprog</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Serial protocol for programming PIC's and EEPROM's with Arduino </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="sect_protocol_defs"></a>
Definitions</h2>
<ul>
<li><b>ProgramPIC</b> refers to the sketch running on the Arduino board that implements the Arduino side of the PIC or EEPROM programming protocol. </li>
<li><b>Host</b> refers to the program running on the computer system connected to the Arduino via USB that manages the PIC programming process. </li>
<li><b>Device</b> refers to the actual PIC in the programming socket that ProgramPIC is talking to. </li>
<li><b>Programming socket</b> refers to the physical connection between ProgramPIC and the device, which may be a ZIF socket, ICSP cable, or some other physical connector.</li>
</ul>
<p>All address and data values in the protocol are sent in hexadecimal. The main notable exceptions are the data payloads to the <a class="el" href="pic_programming_protocol.html#sect_cmd_readbin">READBIN</a> and <a class="el" href="pic_programming_protocol.html#sect_cmd_writebin">WRITEBIN</a> commands that use a compact binary representation instead of hexadecimal.</p>
<h2><a class="anchor" id="sect_addr_space"></a>
Address space</h2>
<p>All commands in this protocol use a flat address space. For example, on the PIC16F628A, program memory runs from 0x0000 to 0x07FF (hex), config memory runs from 0x2000 to 0x2007, and EEPROM runs from 0x2100 to 0x217F. These flat addresses are converted into the correct low-level addressing format by ProgramPIC.</p>
<p>Flat addressing was chosen to simplify the host implementation which will have flat addresses (multiplied by 2 typically) in the hex file. The host does not need to be concerned about the details of switching between addressing modes. If ProgramPIC needs to reset the device to go backwards in memory or switch to a different memory type, then it takes care of that detail internally.</p>
<p>The current implementation of ProgramPIC uses a flat 32-bit address space internally to allow for future expansion. The host should assume 32-bit flat addressing also.</p>
<p>The <a class="el" href="pic_programming_protocol.html#sect_cmd_device">DEVICE</a> and <a class="el" href="pic_programming_protocol.html#sect_cmd_setdevice">SETDEVICE</a> commands are used to retrieve information about the flat address ranges that the device uses for program, config, and data memory. If the device type is unknown to ProgramPIC, then the host may still be able to issue some commands but the results will be unreliable. It is best in this case for the host to issue an error along the lines of "Unsupported device, ID = NNNN".</p>
<h2><a class="anchor" id="sect_command_format"></a>
Command format</h2>
<p>Commands are sent from the host to ProgramPIC in text format, with responses also in text except for certain select binary commands.</p>
<p>A command from the host is a line of ASCII characters, terminated by either a CR (0x0D) or LF (0x0A) character. The line may be up to 64 characters in length, not including the terminator. Additional characters beyond the first 64 are discarded. Fields on a line are separated by either SPACE (0x20) or TAB (0x09) characters, and there can be leading or trailing white space. Blank lines are ignored.</p>
<p>The command is converted to upper case when received by ProgramPIC and before being processed further. Thus, "read", "READ", and "rEaD" are all equivalent to "READ". The following are some examples of commands:</p>
<div class="fragment"><pre class="fragment">PROGRAM_PIC_VERSION
DEVICE
READ 2007
READ 0000-03FF
</pre></div><p>Commands from the host may be terminated with any combination of CR, LF, or CRLF. Text responses from ProgramPIC are always terminated with CRLF.</p>
<p>Most commands can be issued directly to ProgramPIC using a serial communications program, such as the Serial Monitor in the Arduino IDE (make sure to select "Newline" or "Carriage return" line endings). This allows for simple testing and debugging of ProgramPIC but is not suitable for the bulk reads and writes involved in programming a hex file into a PIC. A separate dedicated host program is recommended for bulk operations.</p>
<h2><a class="anchor" id="sect_cmd_unknonwn"></a>
Unknown commands</h2>
<p>If the command is not recognized by ProgramPIC, then it must respond with the line "NOTSUPPORTED", terminated by CRLF. Normal command responses are typically "OK" or "ERROR"; the latter indicating that the command is known but it has failed for some reason.</p>
<h2><a class="anchor" id="sect_cmd_version"></a>
PROGRAM_PIC_VERSION</h2>
<p>The <code>PROGRAM_PIC_VERSION</code> command returns information about ProgramPIC itself rather than the PIC in the programming socket. The currently valid response is a single line of text containing <code>ProgramPIC 1.0</code>, terminated by CRLF.</p>
<p>This command can be used by the host to determine if the Arduino is running a valid version of ProgramPIC or some other sketch. If the host does not receive a valid response within 3 seconds, it should assume that it is not talking to an instance of ProgramPIC.</p>
<p>Note: this command must return exactly the characters <code>ProgramPIC 1.0</code> to be compatible with this version of the protocol. The version response should not be used for vendor-specific strings or settings. A separate command should be used for that purpose.</p>
<p>In the future, version strings of the form <code>ProgramPIC 1.x</code>, where x is a number greater than zero, will be used for extensions to this protocol that remain backwards-compatible. That is, existing commands continue to work as defined here, but new commands may be available. A hypothetical <code>ProgramPIC 2.x</code> version number would indicate a completely new protocol that is not backwards-compatible.</p>
<p>Hosts that implement version 1.0 of the protocol should recognize any higher version, such as 1.1 and 1.2, and continue to operate normally. Hosts that implement version 1.x of the protocol should abort with an error if ProgramPIC responds with version 2.0 or higher.</p>
<h2><a class="anchor" id="sect_cmd_help"></a>
HELP</h2>
<p>The <code>HELP</code> command returns a list of all commands that are understood by ProgramPIC with a brief description. The help details are terminated by a line containing a period.</p>
<p>This command is intended primarily for interactive use via the Serial Monitor in the Arduino IDE. It is not intended to be machine-parsable. Hosts should use the protocol version number to determine whether a command is supported or not.</p>
<h2><a class="anchor" id="sect_cmd_device"></a>
DEVICE</h2>
<p>The <code>DEVICE</code> command is used to retrieve information about the PIC device that is in the programming socket. The device is forcibly reset, important device data is read, and then the device is powered down. A line that starts with a period terminates the returned data. The following is an example of the output:</p>
<div class="fragment"><pre class="fragment">OK
DeviceID: 1066
DeviceName: pic16f628a
ProgramRange: 0000-07FF
ConfigRange: 2000-2007
DataRange: 2100-217F
ConfigWord: 3FFF
.
</pre></div><p>If the programming socket is empty, or the VPP programming voltage is not available, or the PIC cannot be read for some reason (e.g. code protection is enabled), then the <code>DEVICE</code> command will respond with a single line containing <code>ERROR</code>.</p>
<p>Older PIC's do not report a device identifier. These will be reported as <code>DeviceID: 0000</code> (with exactly 4 zeroes). The <a class="el" href="pic_programming_protocol.html#sect_cmd_setdevice">SETDEVICE</a> command must be used by the host to manually specify the device type.</p>
<p>It is required that this command be used before attempting to read or write from the PIC to detect the type of PIC in the programming socket and to ensure that ProgramPIC is using the correct address ranges for program, config, and data memory.</p>
<p>The following information is provided for all PIC types, including those that are not recognized by their device identifier:</p>
<ul>
<li><code>DeviceID</code> presents the raw device identifier of the PIC from config memory location 0x2006. Will be "0000" (exactly 4 zeroes) if there is a PIC in the programming socket but it is an older model that does not have a device identifier. If the device is a standalone EEPROM rather than a PIC, then the <code>DeviceID</code> will also be reported as "0000", but there will be a <code>DeviceName</code> present for the default EEPROM type. </li>
<li><code>ConfigWord</code> presents the contents of the first configuration word. Additional configuration words can be accessed with "READ" once the host knows the <code>ConfigRange</code> (see below). The configuration word will not be present if the device is a standalone EEPROM.</li>
</ul>
<p>If ProgramPIC recognizes the PIC type, then it will also return the following extra information:</p>
<ul>
<li><code>DeviceName</code> presents the name of the device; e.g. "pic16f628a". The revision number can be obtained from the low order bits of <code>DeviceID</code>. </li>
<li><code>ProgramRange</code> gives the range of flat addresses that comprise program memory; e.g. "0000-07FF" for the PIC16F628A. This field will not be present if the device does not have program memory (e.g. a standalone EEPROM). </li>
<li><code>ProgramBits</code> gives the number of significant bits that are used by instructions in program memory. This field is optional and defaults to 14. Value is in decimal, not hexadecimal. </li>
<li><code>ConfigRange</code> gives the range of flat addresses that comprise configuration memory; e.g. "2000-2007". This field will not be present if the device does not have configuration memory (e.g. a standalone EEPROM). </li>
<li><code>ConfigSave</code> is a mask that specifies which bits in the configuration word will be automatically saved by <a class="el" href="pic_programming_protocol.html#sect_cmd_erase">ERASE</a> and <a class="el" href="pic_programming_protocol.html#sect_cmd_write">WRITE</a> because they contain calibration data. This field is optional and defaults to 0. </li>
<li><code>DataRange</code> gives the range of flat addresses that comprise EEPROM data memory; e.g. "2100-217F". This field will not be present if the device does not have data memory. </li>
<li><code>DataBits</code> gives the number of significant bits that are used by locations in data memory. This field is optional and defaults to 8. The number of data bits will typically be 16 for standalone EEPROM's as the data is read and written two bytes at a time. Value is in decimal, not hexadecimal. </li>
<li><code>ReservedRange</code> gives the range of flat addresses that comprise reserved words that will be preserved by an <a class="el" href="pic_programming_protocol.html#sect_cmd_erase">ERASE</a> command. If there is no reserved range of words, then this field will not be present.</li>
</ul>
<p>If the device identifier is not recognized by ProgramPIC, then it may still be possible to issue some commands, but the result will be unreliable; particularly if the host attempts to write data to the PIC device. Thus, if the <code>DeviceName</code> field is not present and <code>DeviceID</code> is non-zero, then the host should report an error along the lines of "Unsupported device, ID = NNNN".</p>
<p>If the <code>DeviceID</code> is zero (PIC present but identifier not available), then the host can use <a class="el" href="pic_programming_protocol.html#sect_cmd_devices">DEVICES</a> to obtain a list of all supported devices, and use <a class="el" href="pic_programming_protocol.html#sect_cmd_setdevice">SETDEVICE</a> to select a specific device type.</p>
<p>The attribute names and values are case-sensitive unless specified otherwise.</p>
<p>Note: if the device locates config memory somewhere other than 0x2000 in flat address space, then the "DEVICE" command will be able to find it and then report the correct range. Using a command like "READ 2007" to read the configuration word is not advisable until the host has retrieved the <code>ConfigRange</code> and determined that the configuration word is indeed located at 0x2007.</p>
<h2><a class="anchor" id="sect_cmd_setdevice"></a>
SETDEVICE</h2>
<p>The <code>SETDEVICE</code> command manually sets the device that ProgramPIC will assume is in the programming socket. This command should be used if <a class="el" href="pic_programming_protocol.html#sect_cmd_device">DEVICE</a> finds a PIC device in the socket but is unable to determine the device identifier.</p>
<p>This command takes a single argument which is the name of the PIC device to set. For example:</p>
<div class="fragment"><pre class="fragment">SETDEVICE pic16f84
</pre></div><p>The command responds with "ERROR" if the device name is not recognized, or with a list of device properties otherwise:</p>
<div class="fragment"><pre class="fragment">OK
DeviceName: pic16f84
ProgramRange: 0000-03FF
ConfigRange: 2000-2007
DataRange: 2100-213F
.
</pre></div><p>Any combination of upper and lower case can be used in the device name: "PIC16F84" and "Pic16f84" will also match the canonical version, "pic16f84".</p>
<h2><a class="anchor" id="sect_cmd_devices"></a>
DEVICES</h2>
<p>The <code>DEVICES</code> command returns a list of all PIC device names that are supported by ProgramPIC, separated by commas, and terminated by a line starting with a period. White space and newlines in the returned list are not significant. The following is an example output:</p>
<div class="fragment"><pre class="fragment">OK
pic12f629*, pic12f630*, pic12f675*, pic12f676*, pic16f84, pic16f84a*,
pic16f87*, pic16f88*, pic16f627*, pic16f627a*, pic16f628*, pic16f628a*,
pic16f648a*
.
</pre></div><p>If the name ends with an asterisk (*), then the device can be autodetected by <a class="el" href="pic_programming_protocol.html#sect_cmd_device">DEVICE</a>. A name without an asterisk can only be selected by using <a class="el" href="pic_programming_protocol.html#sect_cmd_setdevice">SETDEVICE</a>.</p>
<h2><a class="anchor" id="sect_cmd_read"></a>
READ</h2>
<p>The <code>READ</code> command reads words from the device and returns them to the host in ASCII format after a line that says "OK". Each word is separated by spaces or newlines, and the entire response is terminated with a line containing a period. Words are transmitted MSB-first in the hexadecimal representation. Data words will be printed as 16-bit values even though typically only the bottom 8 bits are significant.</p>
<p>The argument to the command is either a single address in hexadecimal or a range of addresses in the form "START-END". All memory locations in the range are read and sent back to the host.</p>
<p>If the address range is badly formatted, out of bounds, start is greater than end, or start and end do not fall within the same memory area (prograrm, config, or data), then the <code>READ</code> command will respond with the line "ERROR".</p>
<p>The following are some examples of reading from a blank PIC16F628A:</p>
<div class="fragment"><pre class="fragment">READ 0000
OK
3FFF
.

READ 2006
OK
1066
.

READ 2060
ERROR

READ 0000-000A
OK
3FFF 3FFF 3FFF 3FFF 3FFF 3FFF 3FFF 3FFF
3FFF 3FFF 3FFF
.

READ 000A-0000
ERROR

READ 0000-217F
ERROR
</pre></div><h2><a class="anchor" id="sect_cmd_readbin"></a>
READBIN</h2>
<p>The <code>READBIN</code> command is identical to <a class="el" href="pic_programming_protocol.html#sect_cmd_read">READ</a> except that after sending the "OK" response, it packs the data into an efficient binary form for faster transmission to the host. This command is recommended for host applications that read bulk data from a PIC.</p>
<p>The response format is a sequence of one or more binary "packets". Each packet starts with a length byte that specifies the number of bytes that follow. The length must not exceed 64 and must be a multiple of 2. A length of zero terminates the response and ProgramPIC returns to waiting for the next command.</p>
<p>After the packet length will be an even number of bytes, as specified by the length. Each pair of bytes specifies the value of a single word in the response, LSB-first.</p>
<p>If <code>READBIN</code> gives an "ERROR" response, its operation will be identical to <a class="el" href="pic_programming_protocol.html#sect_cmd_read">READ</a>.</p>
<h2><a class="anchor" id="sect_cmd_write"></a>
WRITE</h2>
<p>The <code>WRITE</code> command is used to write words to program, config, or data memory. The arguments are the starting address plus one or more word values in hexadecimal, MSB-first. For example:</p>
<div class="fragment"><pre class="fragment">WRITE 0100 1234 1A3F
WRITE 2007 3FFF
WRITE 2100 11 22 33 44
</pre></div><p>Because of ProgramPIC's 64 character limit on commands, it is recommended that no more than 8 words be sent in a single request.</p>
<p>Some devices have preserved bits in the configuration word (e.g. PIC12F675) which will be protected by the <code>WRITE</code> command. To disable this protection and force the value to be written regardless, use the <code>FORCE</code> option:</p>
<div class="fragment"><pre class="fragment">WRITE FORCE 2007 21FF
</pre></div><p>The command will respond with "OK" if the words were written, or "ERROR" if one of the following occurs:</p>
<ul>
<li>The command-line is malformed in some fashion; e.g. invalid characters or missing arguments. </li>
<li>The starting address is not within the range of the program, config, or data memories. </li>
<li>The starting address is within range, but the range overflowed before all words could be written. Words up to the limit will be written. </li>
<li>The write failed for some reason; e.g. no device in the programming socket or the value could not be successfully read back and checked.</li>
</ul>
<p>The host should verify the address range before it sends the command so that the only error case to be handled is a failed write.</p>
<p>Note: the device should be bulk-erased with <a class="el" href="pic_programming_protocol.html#sect_cmd_erase">ERASE</a> before performing write operations.</p>
<h2><a class="anchor" id="sect_cmd_writebin"></a>
WRITEBIN</h2>
<p>The <code>WRITEBIN</code> command is identical to <a class="el" href="pic_programming_protocol.html#sect_cmd_read">WRITE</a> except that it packs the data into an efficient binary form for faster transmission from the host to ProgramPIC. This command is recommended for host applications that write bulk data to a PIC.</p>
<p>The command starts by sending the starting address to ProgramPIC (the <code>FORCE</code> option can also be used):</p>
<div class="fragment"><pre class="fragment">WRITEBIN 0100
</pre></div><p>At this point, the command responds with "OK" or "ERROR". An error occurs if the starting address is out of range or the command is badly formatted.</p>
<p>If the command responds with "OK", then the host is clear to send a <em>single</em> binary packet to ProgramPIC using the same packet format as <a class="el" href="pic_programming_protocol.html#sect_cmd_readbin">READBIN</a>.</p>
<p>ProgramPIC writes the words in the packet to memory and responds with either "OK" or "ERROR". If the response is "ERROR" then the write has failed and the host must stop sending further packets. If the response is "OK", then the host can send another packet to be written into subsequent addresses.</p>
<p>A packet length of zero terminates the <code>WRITEBIN</code> data transfer and ProgramPIC responds with "OK" to acknowledge the terminating packet.</p>
<p>The following is the binary version of "WRITE 0100 1234 1A3F". For ease of discussion, the packets are shown as hex values within angle brackets. In reality they are sent as raw bytes:</p>
<div class="fragment"><pre class="fragment">WRITEBIN 0100
OK
&lt;&lt;04 34 12 3F 1A&gt;&gt;          <span class="comment">// first packet</span>
OK
&lt;&lt;00&gt;&gt;                      <span class="comment">// terminating packet</span>
OK
</pre></div><p>Unlike <a class="el" href="pic_programming_protocol.html#sect_cmd_readbin">READBIN</a> which streams packet data, the host must stop and wait for a response after every written packet. This implements a simple form of flow control to prevent the faster host from overwhelming ProgramPIC with lots of data and overflowing the serial buffers. It will also cause the process to abort early if there is an error, so the host does not have to wait for the entire hexfile to be sent to ProgramPIC before detecting a problem.</p>
<p>If the binary packet length exceeds 64, then additional bytes beyond the first 64 will be discarded. If the packet length is odd, then the extra byte will be discarded. Hosts should never send a binary packet with a length greater than 64 or an odd packet length.</p>
<p>In addition, the length of the first packet must never be 0x0A (10 decimal) or ProgramPIC may become confused between 0x0A used as an LF line terminator in a CRLF pair and 0x0A used as a packet length. If the host needs to write exactly 10 bytes (5 words), then it can either split the packet into two smaller packets or use <a class="el" href="pic_programming_protocol.html#sect_cmd_write">WRITE</a> instead.</p>
<p>ProgramPIC will discard any 0x0A bytes that occur before the first packet. Subsequent packets can have a length byte of 0x0A.</p>
<p>Note: the device should be bulk-erased with <a class="el" href="pic_programming_protocol.html#sect_cmd_erase">ERASE</a> before performing write operations.</p>
<h2><a class="anchor" id="sect_cmd_erase"></a>
ERASE</h2>
<p>The <code>ERASE</code> command performs a bulk erase on all program, config, and data memory in the device. Code and data protection will be disabled. Reserved words (e.g. OSCCAL values) are automatically preserved and written back to program memory afterwards; the host does not need to worry about preserving these values. The command will respond with either "OK" or "ERROR".</p>
<div class="fragment"><pre class="fragment">ERASE
</pre></div><p>If the device has reserved words, then the host can ask that they be erased as well by using the <code>NOPRESERVE</code> option:</p>
<div class="fragment"><pre class="fragment">ERASE NOPRESERVE
</pre></div><p>If <code>NOPRESERVE</code> is given and the device does not have reserved words, then the command will act identically to <code>ERASE</code>. The host should only use <code>NOPRESERVE</code> if it is about to send new data for the reserved words.</p>
<p>Some devices, particularly large EEPROMS in the 24LCXX family, can take longer to erase than the standard 3 second host timeout. The <code>ERASE</code> command should send the line <code>PENDING</code> to the host at least once every two seconds to tell the host that the operation is still in progress. Once the erase completes, the sketch will respond with <code>OK</code> or <code>ERROR</code>.</p>
<h2><a class="anchor" id="sect_cmd_pwroff"></a>
PWROFF</h2>
<p>The <code>PWROFF</code> command turns off the power to the programming socket. ProgramPIC responds with the line "OK". The power will be re-applied automatically when the next command that needs to talk to the programming socket is issued.</p>
<p>This command should be sent by the host once it has completed the programming process. It will then be safe for the user to remove the device from the programming socket and/or replace it with a new device.</p>
<p>The host may also issue this command if it wishes to force the device to reset. Normally this isn't necessary because <a class="el" href="pic_programming_protocol.html#sect_cmd_device">DEVICE</a> will reset the device automatically.</p>
<p>ProgramPIC may itself remove power from the programming socket for various reasons: inactivity timeout or a reset is required to complete the current operation.</p>
<h2><a class="anchor" id="sect_sequence"></a>
Recommended sequence of commands</h2>
<p>The following is the recommended sequence of commands that the host should send to read or program a PIC device:</p>
<ul>
<li><a class="el" href="pic_programming_protocol.html#sect_cmd_version">PROGRAM_PIC_VERSION</a> to discover the version of ProgramPIC that is running on the Arduino. If no response is received, or an incorrect response is received, the host should abort with an error. </li>
<li><a class="el" href="pic_programming_protocol.html#sect_cmd_device">DEVICE</a> to fetch the details of the device that is currently in the programming socket. Abort if the command responds with "ERROR" or the <code>DeviceID</code> is non-zero but <code>DeviceName</code> is not present. </li>
<li>If <a class="el" href="pic_programming_protocol.html#sect_cmd_device">DEVICE</a> returned a <code>DeviceID</code> of zero, then <a class="el" href="pic_programming_protocol.html#sect_cmd_setdevice">SETDEVICE</a> can be used to manually select the device. If <a class="el" href="pic_programming_protocol.html#sect_cmd_setdevice">SETDEVICE</a> reports an error, then <a class="el" href="pic_programming_protocol.html#sect_cmd_devices">DEVICES</a> can be used to fetch the list of supported devices to report an error. </li>
<li>Any number of <a class="el" href="pic_programming_protocol.html#sect_cmd_read">READ</a>, <a class="el" href="pic_programming_protocol.html#sect_cmd_readbin">READBIN</a>, <a class="el" href="pic_programming_protocol.html#sect_cmd_write">WRITE</a>, <a class="el" href="pic_programming_protocol.html#sect_cmd_writebin">WRITEBIN</a>, or <a class="el" href="pic_programming_protocol.html#sect_cmd_erase">ERASE</a> commands to read or progam the PIC device. </li>
<li><a class="el" href="pic_programming_protocol.html#sect_cmd_pwroff">PWROFF</a> to power off the programming socket and make it safe for the user to remove the device. </li>
</ul>
</div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 7 2012 15:08:57 for Ardpicprog by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
