<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ardpicprog: ProgramEEPROM sketch</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ardpicprog</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ProgramEEPROM sketch </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This sketch should be used in place of <a class="el" href="programpic_sketch.html">ProgramPIC</a> when programming a device from the 24LCXX family of standalone EEPROM's. The default implementation supports the 24LC256 device (and equivalent devices such as the 24FC256). Other devices in the family must be specified manually using the host program's <b>--device</b> option:</p>
<div class="fragment"><pre class="fragment">ardpicprog -o out.hex --skip-ones    # defaults to 24lc256
ardpicprog --device 24lc64 -o out.hex --skip-ones
</pre></div><p>The ZIF socket in the <a class="el" href="pic14_zif_circuit.html">PIC programmer shield</a> cannot be used directly with the 24LCXX family of EEPROM devices. An ICSP cable and adapter that uses the following circuit will be needed:</p>
<div class="image">
<img src="eeprom_circuit.png" alt="eeprom_circuit.png"/>
</div>
<p>Because the EEPROM does not use the MCLR/VPP pin on the ICSP header, it is not necessary to connect the 13 volt power supply to the shield while programming EEPROM's. The following photo shows the above circuit made up on a breadboard and connected to the programmer via an ICSP cable:</p>
<div class="image">
<img src="eeprom_circuit_inuse.jpg" alt="eeprom_circuit_inuse.jpg"/>
</div>
<p>The sketch treats the EEPROM as a collection of 16-bit words (LSB first) so as to be compatible with the word-oriented operation of <a class="el" href="programpic_sketch.html">ProgramPIC</a>. This means that the input HEX file must contain an even number of bytes. Each 16-bit word from the HEX file is written to two consecutive 8-bit bytes in the EEPROM's address space. This is slightly different to the handling of data memory in PIC devices which reads 16-bit words from the HEX file but writes only the LSB to the PIC.</p>
<p>The full source code for the ProgramEEPROM sketch follows:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (C) 2012 Southern Storm Software, Pty Ltd.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software: you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation, either version 3 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>       <span class="comment">// For PROGMEM</span>

<span class="comment">// Pin mappings for the PIC programming shield.</span>
<span class="preprocessor">#define PIN_MCLR        A1      // MCLR - not used for EEPROM mode.</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_ACTIVITY    A5      // LED that indicates read/write activity</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_VDD         2       // Controls the power to the PIC</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_CLOCK       4       // Clock pin</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_DATA        7       // Data pin</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define MCLR_RESET      HIGH    // PIN_MCLR state to reset the PIC</span>
<span class="preprocessor"></span><span class="preprocessor">#define MCLR_VPP        LOW     // PIN_MCLR state to apply 13v to MCLR/VPP pin</span>
<span class="preprocessor"></span>
<span class="comment">// All delays are in microseconds.</span>
<span class="preprocessor">#define DELAY_SETTLE    50      // Delay for lines to settle for power off/on</span>
<span class="preprocessor"></span>
<span class="comment">// States this application may be in.</span>
<span class="preprocessor">#define STATE_IDLE      0       // Idle, device is held in the reset state</span>
<span class="preprocessor"></span><span class="preprocessor">#define STATE_PROGRAM   1       // Active, reading and writing memory</span>
<span class="preprocessor"></span><span class="keywordtype">int</span> state = STATE_IDLE;

<span class="comment">// Block select modes within the control byte.</span>
<span class="preprocessor">#define BSEL_NONE           0</span>
<span class="preprocessor"></span><span class="preprocessor">#define BSEL_8BIT_ADDR      1</span>
<span class="preprocessor"></span><span class="preprocessor">#define BSEL_17BIT_ADDR     2</span>
<span class="preprocessor"></span><span class="preprocessor">#define BSEL_17BIT_ADDR_ALT 3</span>
<span class="preprocessor"></span>
<span class="keyword">const</span> prog_char *eepromName;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> eepromSize;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> eepromEnd;
byte eepromI2CAddress;
byte eepromBlockSelectMode;
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eepromPageSize;

<span class="comment">// Device names, forced out into PROGMEM.</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc00[]   PROGMEM = <span class="stringliteral">&quot;24lc00&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc01[]   PROGMEM = <span class="stringliteral">&quot;24lc01&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc014[]  PROGMEM = <span class="stringliteral">&quot;24lc014&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc02[]   PROGMEM = <span class="stringliteral">&quot;24lc02&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc024[]  PROGMEM = <span class="stringliteral">&quot;24lc024&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc025[]  PROGMEM = <span class="stringliteral">&quot;24lc025&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc04[]   PROGMEM = <span class="stringliteral">&quot;24lc04&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc08[]   PROGMEM = <span class="stringliteral">&quot;24lc08&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc16[]   PROGMEM = <span class="stringliteral">&quot;24lc16&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc32[]   PROGMEM = <span class="stringliteral">&quot;24lc32&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc64[]   PROGMEM = <span class="stringliteral">&quot;24lc64&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc128[]  PROGMEM = <span class="stringliteral">&quot;24lc128&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc256[]  PROGMEM = <span class="stringliteral">&quot;24lc256&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc512[]  PROGMEM = <span class="stringliteral">&quot;24lc512&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc1025[] PROGMEM = <span class="stringliteral">&quot;24lc1025&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_24lc1026[] PROGMEM = <span class="stringliteral">&quot;24lc1026&quot;</span>;

<span class="comment">// List of devices that are currently supported and their properties.</span>
<span class="comment">// Note: most of these are based on published information and have not</span>
<span class="comment">// been tested by the author.  Patches welcome to improve the list.</span>
<span class="keyword">struct </span>deviceInfo
{
    <span class="keyword">const</span> prog_char *name;      <span class="comment">// User-readable name of the device.</span>
    prog_uint32_t size;         <span class="comment">// Size of program memory (bytes).</span>
    prog_uint16_t pageSize;     <span class="comment">// Size of a page for bulk transfers.</span>
    prog_uint8_t address;       <span class="comment">// Address on the I2C bus.</span>
    prog_uint8_t blockSelect;   <span class="comment">// Block select mode.</span>

};
<span class="keyword">struct </span>deviceInfo const devices[] PROGMEM = {
    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21178H.pdf</span>
    {s_24lc00, 16UL, 1, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21711J.pdf</span>
    {s_24lc01, 128UL, 8, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21809G.pdf</span>
    {s_24lc014, 128UL, 16, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21709J.pdf</span>
    {s_24lc02, 256UL, 8, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21210N.pdf</span>
    {s_24lc024, 256UL, 16, 0xA0, BSEL_8BIT_ADDR},
    {s_24lc025, 256UL, 16, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21708K.pdf</span>
    {s_24lc04, 512UL, 16, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21710K.pdf</span>
    {s_24lc08, 1024UL, 16, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21703K.pdf</span>
    {s_24lc16, 2048UL, 16, 0xA0, BSEL_8BIT_ADDR},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21713M.pdf</span>
    {s_24lc32, 4096UL, 32, 0xA0, BSEL_NONE},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21189S.pdf</span>
    {s_24lc64, 8192UL, 32, 0xA0, BSEL_NONE},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21191s.pdf</span>
    {s_24lc128, 16384UL, 64, 0xA0, BSEL_NONE},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21203R.pdf</span>
    {s_24lc256, 32768UL, 64, 0xA0, BSEL_NONE},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21754M.pdf</span>
    {s_24lc512, 65536UL, 128, 0xA0, BSEL_NONE},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/21941K.pdf</span>
    {s_24lc1025, 131072UL, 128, 0xA0, BSEL_17BIT_ADDR_ALT},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/22270C.pdf</span>
    {s_24lc1026, 131072UL, 128, 0xA0, BSEL_17BIT_ADDR},

    {0, 0, 0, 0, 0}
};

<span class="comment">// Buffer for command-line character input and READBIN data packets.</span>
<span class="preprocessor">#define BINARY_TRANSFER_MAX 64</span>
<span class="preprocessor"></span><span class="preprocessor">#define BUFFER_MAX (BINARY_TRANSFER_MAX + 1)</span>
<span class="preprocessor"></span><span class="keywordtype">char</span> buffer[BUFFER_MAX];
<span class="keywordtype">int</span> buflen = 0;

<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lastActive = 0;

<span class="keywordtype">void</span> setup()
{
    <span class="comment">// Need a serial link to the host.</span>
    Serial.begin(9600);

    <span class="comment">// Initialize the defaults for the 24LC256.</span>
    setDefaultDeviceInfo();

    <span class="comment">// Hold the chip in the powered down/reset state until we are ready for it.</span>
    pinMode(PIN_MCLR, OUTPUT);
    pinMode(PIN_VDD, OUTPUT);
    digitalWrite(PIN_MCLR, MCLR_RESET);
    digitalWrite(PIN_VDD, LOW);

    <span class="comment">// Initially set the CLOCK and DATA lines to be outputs in the high state.</span>
    pinMode(PIN_CLOCK, OUTPUT);
    pinMode(PIN_DATA, OUTPUT);
    digitalWrite(PIN_CLOCK, HIGH);
    digitalWrite(PIN_DATA, HIGH);

    <span class="comment">// Turn off the activity LED initially.</span>
    pinMode(PIN_ACTIVITY, OUTPUT);
    digitalWrite(PIN_ACTIVITY, LOW);
}

<span class="keywordtype">void</span> loop()
{
    <span class="keywordflow">if</span> (Serial.available()) {
        <span class="comment">// Process serial input for commands from the host.</span>
        <span class="keywordtype">int</span> ch = Serial.read();
        <span class="keywordflow">if</span> (ch == 0x0A || ch == 0x0D) {
            <span class="comment">// End of the current command.  Blank lines are ignored.</span>
            <span class="keywordflow">if</span> (buflen &gt; 0) {
                buffer[buflen] = <span class="charliteral">&#39;\0&#39;</span>;
                buflen = 0;
                digitalWrite(PIN_ACTIVITY, HIGH);   <span class="comment">// Turn on activity LED.</span>
                processCommand(buffer);
                digitalWrite(PIN_ACTIVITY, LOW);    <span class="comment">// Turn off activity LED.</span>
            }
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == 0x08) {
            <span class="comment">// Backspace over the last character.</span>
            <span class="keywordflow">if</span> (buflen &gt; 0)
                --buflen;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (buflen &lt; (BUFFER_MAX - 1)) {
            <span class="comment">// Add the character to the buffer after forcing to upper case.</span>
            <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;z&#39;</span>)
                buffer[buflen++] = ch - <span class="charliteral">&#39;a&#39;</span> + <span class="charliteral">&#39;A&#39;</span>;
            <span class="keywordflow">else</span>
                buffer[buflen++] = ch;
        }
        lastActive = millis();
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state != STATE_IDLE) {
        <span class="comment">// Power off the programming socket if no activity for 2 seconds.</span>
        <span class="comment">// Normally the host will issue the &quot;PWROFF&quot; command, but if we are</span>
        <span class="comment">// operating in interactive mode or the host has crashed, then this</span>
        <span class="comment">// timeout will ensure that the system eventually enters safe mode.</span>
        <span class="keywordflow">if</span> ((millis() - lastActive) &gt;= 2000)
            exitProgramMode();
    }
}

<span class="keywordtype">void</span> printHex1(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
{
    <span class="keywordflow">if</span> (value &gt;= 10)
        Serial.print((<span class="keywordtype">char</span>)(<span class="charliteral">&#39;A&#39;</span> + value - 10));
    <span class="keywordflow">else</span>
        Serial.print((<span class="keywordtype">char</span>)(<span class="charliteral">&#39;0&#39;</span> + value));
}

<span class="keywordtype">void</span> printHex4(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word)
{
    printHex1((word &gt;&gt; 12) &amp; 0x0F);
    printHex1((word &gt;&gt; 8) &amp; 0x0F);
    printHex1((word &gt;&gt; 4) &amp; 0x0F);
    printHex1(word &amp; 0x0F);
}

<span class="keywordtype">void</span> printHex8(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> word)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> upper = (<span class="keywordtype">unsigned</span> int)(word &gt;&gt; 16);
    <span class="keywordflow">if</span> (upper)
        printHex4(upper);
    printHex4((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)word);
}

<span class="keywordtype">void</span> printProgString(<span class="keyword">const</span> prog_char *str)
{
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = (char)(pgm_read_byte(str));
        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;\0&#39;</span>)
            <span class="keywordflow">break</span>;
        Serial.print(ch);
        ++str;
    }
}

<span class="comment">// PROGRAM_PIC_VERSION command.</span>
<span class="keywordtype">void</span> cmdVersion(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    Serial.println(<span class="stringliteral">&quot;ProgramPIC 1.0&quot;</span>);
}

<span class="comment">// Set the defaults for the 24LC256.</span>
<span class="keywordtype">void</span> setDefaultDeviceInfo()
{
    eepromName = s_24lc256;
    eepromSize = 32768UL;
    eepromEnd = (eepromSize / 2) - 1;
    eepromI2CAddress = 0xA0;
    eepromBlockSelectMode = BSEL_NONE;
    eepromPageSize = 64;
}

<span class="comment">// Print the device information.</span>
<span class="keywordtype">void</span> printDeviceInfo()
{
    Serial.print(<span class="stringliteral">&quot;DeviceName: &quot;</span>);
    printProgString(eepromName);
    Serial.println();
    Serial.print(<span class="stringliteral">&quot;DataRange: 0000-&quot;</span>);
    printHex8(eepromEnd);
    Serial.println();
    Serial.println(<span class="stringliteral">&quot;DataBits: 16&quot;</span>);
}

<span class="comment">// Initialize device properties from the &quot;devices&quot; list.</span>
<span class="comment">// Note: &quot;dev&quot; is in PROGMEM.</span>
<span class="keywordtype">void</span> initDevice(<span class="keyword">const</span> <span class="keyword">struct</span> deviceInfo *dev)
{
    eepromName = (<span class="keyword">const</span> prog_char *)pgm_read_word(&amp;(dev-&gt;name));
    eepromSize = pgm_read_dword(&amp;(dev-&gt;size));
    eepromEnd = (eepromSize / 2) - 1;
    eepromI2CAddress = pgm_read_byte(&amp;(dev-&gt;address));
    eepromBlockSelectMode = pgm_read_byte(&amp;(dev-&gt;blockSelect));
    eepromPageSize = pgm_read_word(&amp;(dev-&gt;pageSize));
}

<span class="comment">// DEVICE command.</span>
<span class="keywordtype">void</span> cmdDevice(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="comment">// Start with the chip powered off.</span>
    exitProgramMode();

    <span class="comment">// Probe the I2C bus to see if we have a working EEPROM.</span>
    setDefaultDeviceInfo();
    <span class="keywordflow">if</span> (!probeDevice()) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }

    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);

    Serial.println(<span class="stringliteral">&quot;DeviceID: 0000&quot;</span>);

    printDeviceInfo();

    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// DEVICES command.</span>
<span class="keywordtype">void</span> cmdDevices(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(devices[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (index &gt; 0) {
            Serial.print(<span class="charliteral">&#39;,&#39;</span>);
            <span class="keywordflow">if</span> ((index % 6) == 0)
                Serial.println();
            <span class="keywordflow">else</span>
                Serial.print(<span class="charliteral">&#39; &#39;</span>);
        }
        printProgString(name);
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size = pgm_read_dword(&amp;(devices[index].size));
        <span class="keywordflow">if</span> (size == 32768UL)    <span class="comment">// 24LC256 is the default</span>
            Serial.print(<span class="charliteral">&#39;*&#39;</span>);
        ++index;
    }
    Serial.println();
    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// SETDEVICE command.</span>
<span class="keywordtype">void</span> cmdSetDevice(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="comment">// Start with the chip powered off.</span>
    exitProgramMode();

    <span class="comment">// Extract the name of the device from the command arguments.</span>
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = args[len];
        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;\0&#39;</span> || ch == <span class="charliteral">&#39; &#39;</span> || ch == <span class="charliteral">&#39;\t&#39;</span>)
            <span class="keywordflow">break</span>;
        ++len;
    }

    <span class="comment">// Look for the name in the devices list.</span>
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(devices[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (matchString(name, args, len)) {
            initDevice(&amp;(devices[index]));
            <span class="keywordflow">if</span> (!probeDevice()) {
                <span class="comment">// No device on the bus.</span>
                setDefaultDeviceInfo();
                Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                exitProgramMode();
                <span class="keywordflow">return</span>;
            }
            Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
            printDeviceInfo();
            Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        ++index;
    }
    setDefaultDeviceInfo();
    Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
}

<span class="keywordtype">int</span> parseHex(<span class="keyword">const</span> <span class="keywordtype">char</span> *args, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *value)
{
    <span class="keywordtype">int</span> size = 0;
    *value = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = *args;
        <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;9&#39;</span>)
            *value = (*value &lt;&lt; 4) | (ch - <span class="charliteral">&#39;0&#39;</span>);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;A&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;F&#39;</span>)
            *value = (*value &lt;&lt; 4) | (ch - <span class="charliteral">&#39;A&#39;</span> + 10);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;f&#39;</span>)
            *value = (*value &lt;&lt; 4) | (ch - <span class="charliteral">&#39;a&#39;</span> + 10);
        <span class="keywordflow">else</span>
            <span class="keywordflow">break</span>;
        ++size;
        ++args;
    }
    <span class="keywordflow">if</span> (*args != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; *args != <span class="charliteral">&#39;-&#39;</span> &amp;&amp; *args != <span class="charliteral">&#39; &#39;</span> &amp;&amp; *args != <span class="charliteral">&#39;\t&#39;</span>)
        <span class="keywordflow">return</span> 0;
    <span class="keywordflow">return</span> size;
}

<span class="comment">// Parse a range of addresses of the form START or START-END.</span>
<span class="keywordtype">bool</span> parseRange(<span class="keyword">const</span> <span class="keywordtype">char</span> *args, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *start, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *end)
{
    <span class="keywordtype">int</span> size = parseHex(args, start);
    <span class="keywordflow">if</span> (!size)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    args += size;
    <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
        ++args;
    <span class="keywordflow">if</span> (*args != <span class="charliteral">&#39;-&#39;</span>) {
        *end = *start;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    ++args;
    <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
        ++args;
    <span class="keywordflow">if</span> (!parseHex(args, end))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">return</span> *end &gt;= *start;
}

<span class="keywordtype">bool</span> parseCheckedRange(<span class="keyword">const</span> <span class="keywordtype">char</span> *args, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *start, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *end)
{
    <span class="comment">// Parse the basic values and make sure that start &lt;= end.</span>
    <span class="keywordflow">if</span> (!parseRange(args, start, end))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    <span class="comment">// Check that both start and end are within the same memory area</span>
    <span class="comment">// and within the bounds of that memory area.</span>
    <span class="keywordflow">if</span> (*start &lt;= eepromEnd) {
        <span class="keywordflow">if</span> (*end &gt; eepromEnd)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="comment">// READ command.</span>
<span class="keywordtype">void</span> cmdRead(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> start;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> end;
    <span class="keywordflow">if</span> (!parseCheckedRange(args, &amp;start, &amp;end)) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">if</span> (!startRead(start)) {
        <span class="comment">// No device on the bus.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordflow">while</span> (start &lt;= end) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word = readWord(start == end);
        <span class="keywordflow">if</span> (count &gt; 0) {
            <span class="keywordflow">if</span> ((count % 8) == 0)
                Serial.println();
            <span class="keywordflow">else</span>
                Serial.print(<span class="charliteral">&#39; &#39;</span>);
        }
        printHex4(word);
        ++start;
        ++count;
        <span class="keywordflow">if</span> ((count % 32) == 0) {
            <span class="comment">// Toggle the activity LED to make it blink during long reads.</span>
            activity = !activity;
            <span class="keywordflow">if</span> (activity)
                digitalWrite(PIN_ACTIVITY, HIGH);
            <span class="keywordflow">else</span>
                digitalWrite(PIN_ACTIVITY, LOW);
        }
    }
    Serial.println();
    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// READBIN command.</span>
<span class="keywordtype">void</span> cmdReadBinary(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> start;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> end;
    <span class="keywordflow">if</span> (!parseCheckedRange(args, &amp;start, &amp;end)) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">if</span> (!startRead(start)) {
        <span class="comment">// No device on the bus.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordtype">size_t</span> offset = 0;
    <span class="keywordflow">while</span> (start &lt;= end) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word = readWord(start == end);
        buffer[++offset] = (char)word;
        buffer[++offset] = (char)(word &gt;&gt; 8);
        <span class="keywordflow">if</span> (offset &gt;= BINARY_TRANSFER_MAX) {
            <span class="comment">// Buffer is full - flush it to the host.</span>
            buffer[0] = (char)offset;
            Serial.write((<span class="keyword">const</span> uint8_t *)buffer, offset + 1);
            offset = 0;
        }
        ++start;
        ++count;
        <span class="keywordflow">if</span> ((count % 64) == 0) {
            <span class="comment">// Toggle the activity LED to make it blink during long reads.</span>
            activity = !activity;
            <span class="keywordflow">if</span> (activity)
                digitalWrite(PIN_ACTIVITY, HIGH);
            <span class="keywordflow">else</span>
                digitalWrite(PIN_ACTIVITY, LOW);
        }
    }
    <span class="keywordflow">if</span> (offset &gt; 0) {
        <span class="comment">// Flush the final packet before the terminator.</span>
        buffer[0] = (char)offset;
        Serial.write((<span class="keyword">const</span> uint8_t *)buffer, offset + 1);
    }
    <span class="comment">// Write the terminator (a zero-length packet).</span>
    Serial.write((uint8_t)0x00);
}

<span class="comment">// WRITE command.</span>
<span class="keywordtype">void</span> cmdWrite(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> limit;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;
    <span class="keywordtype">int</span> size;
    size = parseHex(args, &amp;addr);
    <span class="keywordflow">if</span> (!size) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    args += size;
    <span class="keywordflow">if</span> (addr &lt;= eepromEnd) {
        limit = eepromEnd;
    } <span class="keywordflow">else</span> {
        <span class="comment">// Address is not within one of the valid ranges.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    startWrite(addr);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
            ++args;
        <span class="keywordflow">if</span> (*args == <span class="charliteral">&#39;\0&#39;</span>)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (*args == <span class="charliteral">&#39;-&#39;</span>) {
            stopWrite();
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        size = parseHex(args, &amp;value);
        <span class="keywordflow">if</span> (!size) {
            stopWrite();
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        args += size;
        <span class="keywordflow">if</span> (addr &gt; limit) {
            <span class="comment">// We&#39;ve reached the limit of this memory area, so fail.</span>
            stopWrite();
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        <span class="keywordflow">if</span> (!writeWord((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)value)) {
            <span class="comment">// The actual write to the device failed.</span>
            stopWrite();
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        ++addr;
        ++count;
    }
    stopWrite();
    <span class="keywordflow">if</span> (!count) {
        <span class="comment">// Missing word argument.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
    } <span class="keywordflow">else</span> {
        Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    }
}

<span class="comment">// Blocking serial read for use by WRITEBIN.</span>
<span class="keywordtype">int</span> readBlocking()
{
    <span class="keywordflow">while</span> (!Serial.available())
        ;   <span class="comment">// Do nothing.</span>
    <span class="keywordflow">return</span> Serial.read();
}

<span class="comment">// WRITEBIN command.</span>
<span class="keywordtype">void</span> cmdWriteBinary(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> limit;
    <span class="keywordtype">int</span> size;
    size = parseHex(args, &amp;addr);
    <span class="keywordflow">if</span> (!size) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    args += size;
    <span class="keywordflow">if</span> (addr &lt;= eepromEnd) {
        limit = eepromEnd;
    } <span class="keywordflow">else</span> {
        <span class="comment">// Address is not within one of the valid ranges.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    startWrite(addr);
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordflow">for</span> (;;) {
        <span class="comment">// Read in the next binary packet.</span>
        <span class="keywordtype">int</span> len = readBlocking();
        <span class="keywordflow">while</span> (len == 0x0A &amp;&amp; count == 0) {
            <span class="comment">// Skip 0x0A bytes before the first packet as they are</span>
            <span class="comment">// probably part of a CRLF pair rather than a packet length.</span>
            len = readBlocking();
        }

        <span class="comment">// Stop if we have a zero packet length - end of upload.</span>
        <span class="keywordflow">if</span> (!len)
            <span class="keywordflow">break</span>;

        <span class="comment">// Read the contents of the packet from the serial input stream.</span>
        <span class="keywordtype">int</span> offset = 0;
        <span class="keywordflow">while</span> (offset &lt; len) {
            <span class="keywordflow">if</span> (offset &lt; BINARY_TRANSFER_MAX) {
                buffer[offset++] = (char)readBlocking();
            } <span class="keywordflow">else</span> {
                readBlocking();     <span class="comment">// Packet is too big - discard extra bytes.</span>
                ++offset;
            }
        }

        <span class="comment">// Write the words to memory.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> posn = 0; posn &lt; (len - 1); posn += 2) {
            <span class="keywordflow">if</span> (addr &gt; limit) {
                <span class="comment">// We&#39;ve reached the limit of this memory area, so fail.</span>
                stopWrite();
                Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                <span class="keywordflow">return</span>;
            }
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value =
                (((<span class="keywordtype">unsigned</span> int)buffer[posn]) &amp; 0xFF) |
                ((((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)buffer[posn + 1]) &amp; 0xFF) &lt;&lt; 8);
            <span class="keywordflow">if</span> (!writeWord((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)value)) {
                <span class="comment">// The actual write to the device failed.</span>
                stopWrite();
                Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                <span class="keywordflow">return</span>;
            }
            ++addr;
            ++count;
            <span class="keywordflow">if</span> ((count % 24) == 0) {
                <span class="comment">// Toggle the activity LED to make it blink during long writes.</span>
                activity = !activity;
                <span class="keywordflow">if</span> (activity)
                    digitalWrite(PIN_ACTIVITY, HIGH);
                <span class="keywordflow">else</span>
                    digitalWrite(PIN_ACTIVITY, LOW);
            }
        }

        <span class="comment">// All words in this packet have been written successfully.</span>
        Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    }
    stopWrite();
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
}

<span class="comment">// ERASE command.</span>
<span class="keywordtype">void</span> cmdErase(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordflow">if</span> (eraseAll())
        Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordflow">else</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
}

<span class="comment">// PWROFF command.</span>
<span class="keywordtype">void</span> cmdPowerOff(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    exitProgramMode();
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
}

<span class="comment">// List of all commands that are understood by the programmer.</span>
<span class="keyword">typedef</span> void (*commandFunc)(<span class="keyword">const</span> <span class="keywordtype">char</span> *args);
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <span class="keyword">const</span> prog_char *name;
    commandFunc func;
    <span class="keyword">const</span> prog_char *desc;
    <span class="keyword">const</span> prog_char *args;
} command_t;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdRead[] PROGMEM = <span class="stringliteral">&quot;READ&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadDesc[] PROGMEM =
    <span class="stringliteral">&quot;Reads program and data words from device memory (text)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadArgs[] PROGMEM = <span class="stringliteral">&quot;STARTADDR[-ENDADDR]&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadBinary[] PROGMEM = <span class="stringliteral">&quot;READBIN&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadBinaryDesc[] PROGMEM =
    <span class="stringliteral">&quot;Reads program and data words from device memory (binary)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWrite[] PROGMEM = <span class="stringliteral">&quot;WRITE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteDesc[] PROGMEM =
    <span class="stringliteral">&quot;Writes program and data words to device memory (text)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteArgs[] PROGMEM = <span class="stringliteral">&quot;STARTADDR WORD [WORD ...]&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteBinary[] PROGMEM = <span class="stringliteral">&quot;WRITEBIN&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteBinaryDesc[] PROGMEM =
    <span class="stringliteral">&quot;Writes program and data words to device memory (binary)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteBinaryArgs[] PROGMEM = <span class="stringliteral">&quot;STARTADDR&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdErase[] PROGMEM = <span class="stringliteral">&quot;ERASE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdEraseDesc[] PROGMEM =
    <span class="stringliteral">&quot;Erases the contents of program, configuration, and data memory&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDevice[] PROGMEM = <span class="stringliteral">&quot;DEVICE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDeviceDesc[] PROGMEM =
    <span class="stringliteral">&quot;Probes the device and returns information about it&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDevices[] PROGMEM = <span class="stringliteral">&quot;DEVICES&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDevicesDesc[] PROGMEM =
    <span class="stringliteral">&quot;Returns a list of all supported device types&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdSetDevice[] PROGMEM = <span class="stringliteral">&quot;SETDEVICE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdSetDeviceDesc[] PROGMEM =
    <span class="stringliteral">&quot;Sets a specific device type manually&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdSetDeviceArgs[] PROGMEM = <span class="stringliteral">&quot;DEVTYPE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdPowerOff[] PROGMEM = <span class="stringliteral">&quot;PWROFF&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdPowerOffDesc[] PROGMEM =
    <span class="stringliteral">&quot;Powers off the device in the programming socket&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdVersion[] PROGMEM = <span class="stringliteral">&quot;PROGRAM_PIC_VERSION&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdVersionDesc[] PROGMEM =
    <span class="stringliteral">&quot;Prints the version of ProgramPIC&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdHelp[] PROGMEM = <span class="stringliteral">&quot;HELP&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdHelpDesc[] PROGMEM =
    <span class="stringliteral">&quot;Prints this help message&quot;</span>;
<span class="keyword">const</span> command_t commands[] PROGMEM = {
    {s_cmdRead, cmdRead, s_cmdReadDesc, s_cmdReadArgs},
    {s_cmdReadBinary, cmdReadBinary, s_cmdReadBinaryDesc, s_cmdReadArgs},
    {s_cmdWrite, cmdWrite, s_cmdWriteDesc, s_cmdWriteArgs},
    {s_cmdWriteBinary, cmdWriteBinary, s_cmdWriteBinaryDesc, s_cmdWriteBinaryArgs},
    {s_cmdErase, cmdErase, s_cmdEraseDesc, 0},
    {s_cmdDevice, cmdDevice, s_cmdDeviceDesc, 0},
    {s_cmdDevices, cmdDevices, s_cmdDevicesDesc, 0},
    {s_cmdSetDevice, cmdSetDevice, s_cmdSetDeviceDesc, s_cmdSetDeviceArgs},
    {s_cmdPowerOff, cmdPowerOff, s_cmdPowerOffDesc, 0},
    {s_cmdVersion, cmdVersion, s_cmdVersionDesc, 0},
    {s_cmdHelp, cmdHelp, s_cmdHelpDesc, 0},
    {0, 0}
};

<span class="comment">// &quot;HELP&quot; command.</span>
<span class="keywordtype">void</span> cmdHelp(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keyword">const</span> prog_char *desc = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].desc)));
        <span class="keyword">const</span> prog_char *args = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].args)));
        printProgString(name);
        <span class="keywordflow">if</span> (args) {
            Serial.print(<span class="charliteral">&#39; &#39;</span>);
            printProgString(args);
        }
        Serial.println();
        Serial.print(<span class="stringliteral">&quot;    &quot;</span>);
        printProgString(desc);
        Serial.println();
        ++index;
    }
    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// Match a data-space string where the name comes from PROGMEM.</span>
<span class="keywordtype">bool</span> matchString(<span class="keyword">const</span> prog_char *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len)
{
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch1 = (char)(pgm_read_byte(name));
        <span class="keywordflow">if</span> (ch1 == <span class="charliteral">&#39;\0&#39;</span>)
            <span class="keywordflow">return</span> len == 0;
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len == 0)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (ch1 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch1 &lt;= <span class="charliteral">&#39;z&#39;</span>)
            ch1 = ch1 - <span class="charliteral">&#39;a&#39;</span> + <span class="charliteral">&#39;A&#39;</span>;
        <span class="keywordtype">char</span> ch2 = *str;
        <span class="keywordflow">if</span> (ch2 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch2 &lt;= <span class="charliteral">&#39;z&#39;</span>)
            ch2 = ch2 - <span class="charliteral">&#39;a&#39;</span> + <span class="charliteral">&#39;A&#39;</span>;
        <span class="keywordflow">if</span> (ch1 != ch2)
            <span class="keywordflow">break</span>;
        ++name;
        ++str;
        --len;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}

<span class="comment">// Process commands from the host.</span>
<span class="keywordtype">void</span> processCommand(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf)
{
    <span class="comment">// Skip white space at the start of the command.</span>
    <span class="keywordflow">while</span> (*buf == <span class="charliteral">&#39; &#39;</span> || *buf == <span class="charliteral">&#39;\t&#39;</span>)
        ++buf;
    <span class="keywordflow">if</span> (*buf == <span class="charliteral">&#39;\0&#39;</span>)
        <span class="keywordflow">return</span>;     <span class="comment">// Ignore blank lines.</span>

    <span class="comment">// Extract the command portion of the line.</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span> *cmd = buf;
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = *buf;
        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;\0&#39;</span> || ch == <span class="charliteral">&#39; &#39;</span> || ch == <span class="charliteral">&#39;\t&#39;</span>)
            <span class="keywordflow">break</span>;
        ++buf;
        ++len;
    }

    <span class="comment">// Skip white space after the command name and before the arguments.</span>
    <span class="keywordflow">while</span> (*buf == <span class="charliteral">&#39; &#39;</span> || *buf == <span class="charliteral">&#39;\t&#39;</span>)
        ++buf;

    <span class="comment">// Find the command and execute it.</span>
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (matchString(name, cmd, len)) {
            commandFunc func =
                (commandFunc)(pgm_read_word(&amp;(commands[index].func)));
            (*func)(buf);
            <span class="keywordflow">return</span>;
        }
        ++index;
    }

    <span class="comment">// Unknown command.</span>
    Serial.println(<span class="stringliteral">&quot;NOTSUPPORTED&quot;</span>);
}

<span class="comment">// Enter programming mode.</span>
<span class="keywordtype">void</span> enterProgramMode()
{
    <span class="comment">// Bail out if already in programming mode.</span>
    <span class="keywordflow">if</span> (state != STATE_IDLE)
        <span class="keywordflow">return</span>;

    <span class="comment">// Lower VDD, which will power off the chip just in case.</span>
    digitalWrite(PIN_VDD, LOW);

    <span class="comment">// Make sure that CLOCK and DATA are high.</span>
    pinMode(PIN_CLOCK, OUTPUT);
    pinMode(PIN_DATA, OUTPUT);
    digitalWrite(PIN_CLOCK, HIGH);
    digitalWrite(PIN_DATA, HIGH);

    <span class="comment">// Wait for the lines to settle.</span>
    delayMicroseconds(DELAY_SETTLE);

    <span class="comment">// Raise VDD.</span>
    digitalWrite(PIN_VDD, HIGH);
    delayMicroseconds(DELAY_SETTLE);

    <span class="comment">// Now in program mode, address not set yet.</span>
    state = STATE_PROGRAM;
}

<span class="comment">// Exit programming mode and reset the device.</span>
<span class="keywordtype">void</span> exitProgramMode()
{
    <span class="comment">// Nothing to do if already out of programming mode.</span>
    <span class="keywordflow">if</span> (state == STATE_IDLE)
        <span class="keywordflow">return</span>;

    <span class="comment">// Lower VDD.</span>
    digitalWrite(PIN_VDD, LOW);

    <span class="comment">// Return the CLOCK and DATA lines to the pulled-high state.</span>
    pinMode(PIN_CLOCK, OUTPUT);
    pinMode(PIN_DATA, OUTPUT);
    digitalWrite(PIN_CLOCK, HIGH);
    digitalWrite(PIN_DATA, HIGH);

    <span class="comment">// Now in the idle state with the chip powered off.</span>
    state = STATE_IDLE;
}

<span class="comment">// Details of the I2C protocol here: http://en.wikipedia.org/wiki/I2C</span>
<span class="comment">// Assumptions: only one master, no arbitration, and no clock stretching.</span>

<span class="preprocessor">#define i2cDelay()  delayMicroseconds(5)</span>
<span class="preprocessor"></span>
<span class="keywordtype">bool</span> started = <span class="keyword">false</span>;

<span class="keywordtype">void</span> i2cStart()
{
    pinMode(PIN_DATA, OUTPUT);
    <span class="keywordflow">if</span> (started) {
        <span class="comment">// Already started, so send a restart condition.</span>
        digitalWrite(PIN_DATA, HIGH);
        digitalWrite(PIN_CLOCK, HIGH);
        i2cDelay();
    }
    digitalWrite(PIN_DATA, LOW);
    i2cDelay();
    digitalWrite(PIN_CLOCK, LOW);
    i2cDelay();
    started = <span class="keyword">true</span>;
}

<span class="keywordtype">void</span> i2cStop()
{
    pinMode(PIN_DATA, OUTPUT);
    digitalWrite(PIN_DATA, LOW);
    digitalWrite(PIN_CLOCK, HIGH);
    i2cDelay();
    digitalWrite(PIN_DATA, HIGH);
    i2cDelay();
    started = <span class="keyword">false</span>;
}

<span class="keyword">inline</span> <span class="keywordtype">void</span> i2cWriteBit(<span class="keywordtype">bool</span> bit)
{
    pinMode(PIN_DATA, OUTPUT);
    <span class="keywordflow">if</span> (bit)
        digitalWrite(PIN_DATA, HIGH);
    <span class="keywordflow">else</span>
        digitalWrite(PIN_DATA, LOW);
    i2cDelay();
    digitalWrite(PIN_CLOCK, HIGH);
    i2cDelay();
    digitalWrite(PIN_CLOCK, LOW);
    i2cDelay();
}

<span class="keyword">inline</span> <span class="keywordtype">bool</span> i2cReadBit()
{
    pinMode(PIN_DATA, INPUT);
    digitalWrite(PIN_DATA, HIGH);
    digitalWrite(PIN_CLOCK, HIGH);
    <span class="keywordtype">bool</span> bit = digitalRead(PIN_DATA);
    i2cDelay();
    digitalWrite(PIN_CLOCK, LOW);
    i2cDelay();
    <span class="keywordflow">return</span> bit;
}

<span class="preprocessor">#define I2C_ACK     false</span>
<span class="preprocessor"></span><span class="preprocessor">#define I2C_NACK    true</span>
<span class="preprocessor"></span>
<span class="keywordtype">bool</span> i2cWrite(byte value)
{
    byte mask = 0x80;
    <span class="keywordflow">while</span> (mask != 0) {
        i2cWriteBit((value &amp; mask) != 0);
        mask &gt;&gt;= 1;
    }
    <span class="keywordflow">return</span> i2cReadBit();
}

byte i2cRead(<span class="keywordtype">bool</span> nack)
{
    byte value = 0;
    <span class="keywordflow">for</span> (byte bit = 0; bit &lt; 8; ++bit)
        value = (value &lt;&lt; 1) | i2cReadBit();
    i2cWriteBit(nack);
    <span class="keywordflow">return</span> value;
}

<span class="preprocessor">#define I2C_READ    0x01</span>
<span class="preprocessor"></span><span class="preprocessor">#define I2C_WRITE   0x00</span>
<span class="preprocessor"></span>
<span class="keywordtype">bool</span> writeAddress(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> byteAddr)
{
    byte ctrl;
    <span class="keywordflow">switch</span> (eepromBlockSelectMode) {
    <span class="keywordflow">case</span> BSEL_NONE:
        <span class="keywordflow">if</span> (i2cWrite(eepromI2CAddress | I2C_WRITE) == I2C_NACK)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        i2cWrite((byte)(byteAddr &gt;&gt; 8));
        i2cWrite((byte)byteAddr);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> BSEL_8BIT_ADDR:
        ctrl = eepromI2CAddress | ((byte)(byteAddr &gt;&gt; 7) &amp; 0x0E) | I2C_WRITE;
        <span class="keywordflow">if</span> (i2cWrite(ctrl) == I2C_NACK)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        i2cWrite((byte)byteAddr);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> BSEL_17BIT_ADDR:
        ctrl = eepromI2CAddress | ((byte)(byteAddr &gt;&gt; 15) &amp; 0x02) | I2C_WRITE;
        <span class="keywordflow">if</span> (i2cWrite(ctrl) == I2C_NACK)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        i2cWrite((byte)(byteAddr &gt;&gt; 8));
        i2cWrite((byte)byteAddr);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> BSEL_17BIT_ADDR_ALT:
        ctrl = eepromI2CAddress | ((byte)(byteAddr &gt;&gt; 13) &amp; 0x08) | I2C_WRITE;
        <span class="keywordflow">if</span> (i2cWrite(ctrl) == I2C_NACK)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        i2cWrite((byte)(byteAddr &gt;&gt; 8));
        i2cWrite((byte)byteAddr);
        <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="comment">// Start a bulk read operation.</span>
<span class="keywordtype">bool</span> startRead(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr)
{
    enterProgramMode();
    i2cStart();
    <span class="keywordflow">if</span> (!writeAddress(addr * 2))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    i2cStart();
    <span class="keywordflow">return</span> i2cWrite(eepromI2CAddress | I2C_READ) == I2C_ACK;
}

<span class="comment">// Read the next 16-bit word from the EEPROM during a bulk read operation.</span>
<span class="comment">// If &quot;last&quot; is true then stop the bulk read operation after reading the word.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> readWord(<span class="keywordtype">bool</span> last)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value = i2cRead(I2C_ACK);
    value |= ((<span class="keywordtype">unsigned</span> int)(i2cRead(last))) &lt;&lt; 8;
    <span class="keywordflow">if</span> (last)
        i2cStop();
    <span class="keywordflow">return</span> value;
}

<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> writeByteAddr;
<span class="keywordtype">bool</span> writeAddrNeeded;

<span class="comment">// Start a bulk write operation.</span>
<span class="keywordtype">void</span> startWrite(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr)
{
    enterProgramMode();
    writeByteAddr = addr * 2;
    writeAddrNeeded = <span class="keyword">true</span>;
}

<span class="comment">// Write a 16-bit word during a bulk write operation.</span>
<span class="keywordtype">bool</span> writeWord(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word)
{
    <span class="keywordflow">if</span> (writeAddrNeeded) {
        i2cStart();
        <span class="keywordflow">if</span> (!writeAddress(writeByteAddr)) {
            i2cStop();
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
        writeAddrNeeded = <span class="keyword">false</span>;
    }
    i2cWrite((byte)word);
    <span class="keywordflow">if</span> (eepromPageSize == 1) {
        <span class="comment">// 24LC00 needs a flush after every byte that is written.</span>
        i2cStop();
        <span class="keywordflow">for</span> (;;) {
            <span class="comment">// Poll until we get an acknowledgement from the EEPROM.</span>
            i2cStart();
            <span class="keywordflow">if</span> (i2cWrite(eepromI2CAddress | I2C_WRITE) == I2C_ACK)
                <span class="keywordflow">break</span>;
        }
        i2cStop();
        i2cStart();
        <span class="keywordflow">if</span> (!writeAddress(writeByteAddr + 1)) {
            i2cStop();
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
    }
    i2cWrite((byte)(word &gt;&gt; 8));
    writeByteAddr += 2;
    <span class="keywordflow">if</span> ((writeByteAddr % eepromPageSize) == 0) {
        <span class="comment">// Overflow into the next page, so need to flush and send a new address.</span>
        i2cStop();
        <span class="keywordflow">for</span> (;;) {
            <span class="comment">// Poll until we get an acknowledgement from the EEPROM.</span>
            i2cStart();
            <span class="keywordflow">if</span> (i2cWrite(eepromI2CAddress | I2C_WRITE) == I2C_ACK)
                <span class="keywordflow">break</span>;
        }
        i2cStop();
        writeAddrNeeded = <span class="keyword">true</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="comment">// Stop a bulk write operation.</span>
<span class="keywordtype">void</span> stopWrite()
{
    <span class="keywordflow">if</span> (!writeAddrNeeded) {
        <span class="comment">// Flush the final page write operation.</span>
        i2cStop();
        <span class="keywordflow">for</span> (;;) {
            <span class="comment">// Poll until we get an acknowledgement from the EEPROM.</span>
            i2cStart();
            <span class="keywordflow">if</span> (i2cWrite(eepromI2CAddress | I2C_WRITE) == I2C_ACK)
                <span class="keywordflow">break</span>;
        }
        i2cStop();
    }
}

<span class="comment">// Erases all bytes within the EEPROM by setting them to 0xFF.</span>
<span class="keywordtype">bool</span> eraseAll()
{
    enterProgramMode();

    <span class="comment">// Fill the bytes a page at a time.</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> startTime = millis();
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> currentTime;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordflow">while</span> (addr &lt; eepromSize) {
        i2cStart();
        <span class="keywordflow">if</span> (!writeAddress(addr))
            <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// No device on the bus.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = 0; count &lt; eepromPageSize; ++count)
            i2cWrite(0xFF);
        i2cStop();
        <span class="keywordflow">for</span> (;;) {
            <span class="comment">// Poll until we get an acknowledgement from the EEPROM.</span>
            i2cStart();
            <span class="keywordflow">if</span> (i2cWrite(eepromI2CAddress | I2C_WRITE) == I2C_ACK)
                <span class="keywordflow">break</span>;
        }
        i2cStop();
        addr += eepromPageSize;
        <span class="keywordflow">if</span> ((addr % 512) == 0) {
            activity = !activity;
            <span class="keywordflow">if</span> (activity)
                digitalWrite(PIN_ACTIVITY, HIGH);
            <span class="keywordflow">else</span>
                digitalWrite(PIN_ACTIVITY, LOW);
        }
        currentTime = millis();
        <span class="keywordflow">if</span> ((currentTime - startTime) &gt;= 2000) {
            <span class="comment">// Erase has been running for too long, so ask the host to wait.</span>
            Serial.println(<span class="stringliteral">&quot;PENDING&quot;</span>);
            startTime = currentTime;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="comment">// Probe the device to see if it is present on the bus.  We do this by</span>
<span class="comment">// doing a &quot;Current Address Read&quot; and checking for the presence of ACK bits.</span>
<span class="keywordtype">bool</span> probeDevice()
{
    enterProgramMode();
    i2cStart();
    <span class="keywordflow">if</span> (i2cWrite(eepromI2CAddress | I2C_READ) == I2C_NACK)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    i2cRead(I2C_NACK);
    i2cStop();
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div> </div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 7 2012 14:24:18 for Ardpicprog by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
