<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ardpicprog: ProgramPIC sketch</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ardpicprog</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ProgramPIC sketch </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This sketch should be uploaded to an Arduino Uno compatible board that has a <a class="el" href="pic14_zif_circuit.html">PIC programming shield</a> attached to it. The shield must be suitable for the PIC device that is being programmed. See the <a class="el" href="supported_devices.html">list of supported devices</a> for more information.</p>
<p>If you are programming an EEPROM from the 24LCXX family, then use the <a class="el" href="programeeprom_sketch.html">ProgramEEPROM</a> sketch instead.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (C) 2012 Southern Storm Software, Pty Ltd.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software: you can redistribute it and/or modify</span>
<span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<span class="comment"> * the Free Software Foundation, either version 3 of the License, or</span>
<span class="comment"> * (at your option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"> * GNU General Public License for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License</span>
<span class="comment"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>       <span class="comment">// For PROGMEM</span>

<span class="comment">// Pin mappings for the PIC programming shield.</span>
<span class="preprocessor">#define PIN_MCLR        A1      // 0: MCLR is VPP voltage, 1: Reset PIC</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_ACTIVITY    A5      // LED that indicates read/write activity</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_VDD         2       // Controls the power to the PIC</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_CLOCK       4       // Clock pin</span>
<span class="preprocessor"></span><span class="preprocessor">#define PIN_DATA        7       // Data pin</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define MCLR_RESET      HIGH    // PIN_MCLR state to reset the PIC</span>
<span class="preprocessor"></span><span class="preprocessor">#define MCLR_VPP        LOW     // PIN_MCLR state to apply 13v to MCLR/VPP pin</span>
<span class="preprocessor"></span>
<span class="comment">// All delays are in microseconds.</span>
<span class="preprocessor">#define DELAY_SETTLE    50      // Delay for lines to settle for reset</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TPPDP     5       // Hold time after raising MCLR</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_THLD0     5       // Hold time after raising VDD</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TSET1     1       // Data in setup time before lowering clock</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_THLD1     1       // Data in hold time after lowering clock</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TDLY2     1       // Delay between commands or data</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TDLY3     1       // Delay until data bit read will be valid</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TPROG     4000    // Time for a program memory write to complete</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TDPROG    6000    // Time for a data memory write to complete</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TERA      6000    // Time for a word erase to complete</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TPROG5    1000    // Time for program write on FLASH5 systems</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TFULLERA  50000   // Time for a full chip erase</span>
<span class="preprocessor"></span><span class="preprocessor">#define DELAY_TFULL84   20000   // Intermediate wait for PIC16F84/PIC16F84A</span>
<span class="preprocessor"></span>
<span class="comment">// Commands that may be sent to the device.</span>
<span class="preprocessor">#define CMD_LOAD_CONFIG         0x00    // Load (write) to config memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_LOAD_PROGRAM_MEMORY 0x02    // Load to program memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_LOAD_DATA_MEMORY    0x03    // Load to data memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_INCREMENT_ADDRESS   0x06    // Increment the PC</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_READ_PROGRAM_MEMORY 0x04    // Read from program memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_READ_DATA_MEMORY    0x05    // Read from data memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_BEGIN_PROGRAM       0x08    // Begin programming with erase cycle</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_BEGIN_PROGRAM_ONLY  0x18    // Begin programming only cycle</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_END_PROGRAM_ONLY    0x17    // End programming only cycle</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_BULK_ERASE_PROGRAM  0x09    // Bulk erase program memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_BULK_ERASE_DATA     0x0B    // Bulk erase data memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define CMD_CHIP_ERASE          0x1F    // Erase the entire chip</span>
<span class="preprocessor"></span>
<span class="comment">// States this application may be in.</span>
<span class="preprocessor">#define STATE_IDLE      0       // Idle, device is held in the reset state</span>
<span class="preprocessor"></span><span class="preprocessor">#define STATE_PROGRAM   1       // Active, reading and writing program memory</span>
<span class="preprocessor"></span><span class="preprocessor">#define STATE_CONFIG    2       // Active, reading and writing config memory</span>
<span class="preprocessor"></span><span class="keywordtype">int</span> state = STATE_IDLE;

<span class="comment">// Flash types.  Uses a similar naming system to picprog.</span>
<span class="preprocessor">#define EEPROM          0</span>
<span class="preprocessor"></span><span class="preprocessor">#define FLASH           1</span>
<span class="preprocessor"></span><span class="preprocessor">#define FLASH4          4</span>
<span class="preprocessor"></span><span class="preprocessor">#define FLASH5          5</span>
<span class="preprocessor"></span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pc = 0;           <span class="comment">// Current program counter.</span>

<span class="comment">// Flat address ranges for the various memory spaces.  Defaults to the values</span>
<span class="comment">// for the PIC16F628A.  &quot;DEVICE&quot; command updates to the correct values later.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> programEnd    = 0x07FF;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> configStart   = 0x2000;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> configEnd     = 0x2007;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dataStart     = 0x2100;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dataEnd       = 0x217F;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reservedStart = 0x0800;
<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reservedEnd   = 0x07FF;
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  configSave    = 0x0000;
byte progFlashType          = FLASH4;
byte dataFlashType          = EEPROM;

<span class="comment">// Device names, forced out into PROGMEM.</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic12f629[]  PROGMEM = <span class="stringliteral">&quot;pic12f629&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic12f630[]  PROGMEM = <span class="stringliteral">&quot;pic12f630&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic12f675[]  PROGMEM = <span class="stringliteral">&quot;pic12f675&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic12f676[]  PROGMEM = <span class="stringliteral">&quot;pic12f676&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f84[]   PROGMEM = <span class="stringliteral">&quot;pic16f84&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f84a[]  PROGMEM = <span class="stringliteral">&quot;pic16f84a&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f87[]   PROGMEM = <span class="stringliteral">&quot;pic16f87&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f88[]   PROGMEM = <span class="stringliteral">&quot;pic16f88&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f627[]  PROGMEM = <span class="stringliteral">&quot;pic16f627&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f627a[] PROGMEM = <span class="stringliteral">&quot;pic16f627a&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f628[]  PROGMEM = <span class="stringliteral">&quot;pic16f628&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f628a[] PROGMEM = <span class="stringliteral">&quot;pic16f628a&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_pic16f648a[] PROGMEM = <span class="stringliteral">&quot;pic16f648a&quot;</span>;

<span class="comment">// List of devices that are currently supported and their properties.</span>
<span class="comment">// Note: most of these are based on published information and have not</span>
<span class="comment">// been tested by the author.  Patches welcome to improve the list.</span>
<span class="keyword">struct </span>deviceInfo
{
    <span class="keyword">const</span> prog_char *name;      <span class="comment">// User-readable name of the device.</span>
    prog_int16_t deviceId;      <span class="comment">// Device ID for the PIC (-1 if no id).</span>
    prog_uint32_t programSize;  <span class="comment">// Size of program memory (words).</span>
    prog_uint32_t configStart;  <span class="comment">// Flat address start of configuration memory.</span>
    prog_uint32_t dataStart;    <span class="comment">// Flat address start of EEPROM data memory.</span>
    prog_uint16_t configSize;   <span class="comment">// Number of configuration words.</span>
    prog_uint16_t dataSize;     <span class="comment">// Size of EEPROM data memory (bytes).</span>
    prog_uint16_t reservedWords;<span class="comment">// Reserved program words (e.g. for OSCCAL).</span>
    prog_uint16_t configSave;   <span class="comment">// Bits in config word to be saved.</span>
    prog_uint8_t progFlashType; <span class="comment">// Type of flash for program memory.</span>
    prog_uint8_t dataFlashType; <span class="comment">// Type of flash for data memory.</span>

};
<span class="keyword">struct </span>deviceInfo const devices[] PROGMEM = {
    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/41191D.pdf</span>
    {s_pic12f629,  0x0F80, 1024, 0x2000, 0x2100, 8, 128, 1, 0x3000, FLASH4, EEPROM},
    {s_pic12f630,  0x10C0, 1024, 0x2000, 0x2100, 8, 128, 1, 0x3000, FLASH4, EEPROM},
    {s_pic12f675,  0x0FC0, 1024, 0x2000, 0x2100, 8, 128, 1, 0x3000, FLASH4, EEPROM},
    {s_pic12f676,  0x10E0, 1024, 0x2000, 0x2100, 8, 128, 1, 0x3000, FLASH4, EEPROM},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/30262e.pdf</span>
    {s_pic16f84,   -1,     1024, 0x2000, 0x2100, 8,  64, 0, 0, FLASH,  EEPROM},
    {s_pic16f84a,  0x0560, 1024, 0x2000, 0x2100, 8,  64, 0, 0, FLASH,  EEPROM},

    <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/39607c.pdf</span>
    {s_pic16f87,   0x0720, 4096, 0x2000, 0x2100, 9, 256, 0, 0, FLASH5, EEPROM},
    {s_pic16f88,   0x0760, 4096, 0x2000, 0x2100, 9, 256, 0, 0, FLASH5, EEPROM},

    <span class="comment">// 627/628:  http://ww1.microchip.com/downloads/en/DeviceDoc/30034d.pdf</span>
    <span class="comment">// A series: http://ww1.microchip.com/downloads/en/DeviceDoc/41196g.pdf</span>
    {s_pic16f627,  0x07A0, 1024, 0x2000, 0x2100, 8, 128, 0, 0, FLASH,  EEPROM},
    {s_pic16f627a, 0x1040, 1024, 0x2000, 0x2100, 8, 128, 0, 0, FLASH4, EEPROM},
    {s_pic16f628,  0x07C0, 2048, 0x2000, 0x2100, 8, 128, 0, 0, FLASH,  EEPROM},
    {s_pic16f628a, 0x1060, 2048, 0x2000, 0x2100, 8, 128, 0, 0, FLASH4, EEPROM},
    {s_pic16f648a, 0x1100, 4096, 0x2000, 0x2100, 8, 256, 0, 0, FLASH4, EEPROM},

    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

<span class="comment">// Buffer for command-line character input and READBIN data packets.</span>
<span class="preprocessor">#define BINARY_TRANSFER_MAX 64</span>
<span class="preprocessor"></span><span class="preprocessor">#define BUFFER_MAX (BINARY_TRANSFER_MAX + 1)</span>
<span class="preprocessor"></span><span class="keywordtype">char</span> buffer[BUFFER_MAX];
<span class="keywordtype">int</span> buflen = 0;

<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lastActive = 0;

<span class="keywordtype">void</span> setup()
{
    <span class="comment">// Need a serial link to the host.</span>
    Serial.begin(9600);

    <span class="comment">// Hold the PIC in the powered down/reset state until we are ready for it.</span>
    pinMode(PIN_MCLR, OUTPUT);
    pinMode(PIN_VDD, OUTPUT);
    digitalWrite(PIN_MCLR, MCLR_RESET);
    digitalWrite(PIN_VDD, LOW);

    <span class="comment">// Clock and data are floating until the first PIC command.</span>
    pinMode(PIN_CLOCK, INPUT);
    pinMode(PIN_DATA, INPUT);

    <span class="comment">// Turn off the activity LED initially.</span>
    pinMode(PIN_ACTIVITY, OUTPUT);
    digitalWrite(PIN_ACTIVITY, LOW);
}

<span class="keywordtype">void</span> loop()
{
    <span class="keywordflow">if</span> (Serial.available()) {
        <span class="comment">// Process serial input for commands from the host.</span>
        <span class="keywordtype">int</span> ch = Serial.read();
        <span class="keywordflow">if</span> (ch == 0x0A || ch == 0x0D) {
            <span class="comment">// End of the current command.  Blank lines are ignored.</span>
            <span class="keywordflow">if</span> (buflen &gt; 0) {
                buffer[buflen] = <span class="charliteral">&#39;\0&#39;</span>;
                buflen = 0;
                digitalWrite(PIN_ACTIVITY, HIGH);   <span class="comment">// Turn on activity LED.</span>
                processCommand(buffer);
                digitalWrite(PIN_ACTIVITY, LOW);    <span class="comment">// Turn off activity LED.</span>
            }
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == 0x08) {
            <span class="comment">// Backspace over the last character.</span>
            <span class="keywordflow">if</span> (buflen &gt; 0)
                --buflen;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (buflen &lt; (BUFFER_MAX - 1)) {
            <span class="comment">// Add the character to the buffer after forcing to upper case.</span>
            <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;z&#39;</span>)
                buffer[buflen++] = ch - <span class="charliteral">&#39;a&#39;</span> + <span class="charliteral">&#39;A&#39;</span>;
            <span class="keywordflow">else</span>
                buffer[buflen++] = ch;
        }
        lastActive = millis();
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state != STATE_IDLE) {
        <span class="comment">// Power off the programming socket if no activity for 2 seconds.</span>
        <span class="comment">// Normally the host will issue the &quot;PWROFF&quot; command, but if we are</span>
        <span class="comment">// operating in interactive mode or the host has crashed, then this</span>
        <span class="comment">// timeout will ensure that the system eventually enters safe mode.</span>
        <span class="keywordflow">if</span> ((millis() - lastActive) &gt;= 2000)
            exitProgramMode();
    }
}

<span class="keywordtype">void</span> printHex1(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
{
    <span class="keywordflow">if</span> (value &gt;= 10)
        Serial.print((<span class="keywordtype">char</span>)(<span class="charliteral">&#39;A&#39;</span> + value - 10));
    <span class="keywordflow">else</span>
        Serial.print((<span class="keywordtype">char</span>)(<span class="charliteral">&#39;0&#39;</span> + value));
}

<span class="keywordtype">void</span> printHex4(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word)
{
    printHex1((word &gt;&gt; 12) &amp; 0x0F);
    printHex1((word &gt;&gt; 8) &amp; 0x0F);
    printHex1((word &gt;&gt; 4) &amp; 0x0F);
    printHex1(word &amp; 0x0F);
}

<span class="keywordtype">void</span> printHex8(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> word)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> upper = (<span class="keywordtype">unsigned</span> int)(word &gt;&gt; 16);
    <span class="keywordflow">if</span> (upper)
        printHex4(upper);
    printHex4((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)word);
}

<span class="keywordtype">void</span> printProgString(<span class="keyword">const</span> prog_char *str)
{
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = (char)(pgm_read_byte(str));
        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;\0&#39;</span>)
            <span class="keywordflow">break</span>;
        Serial.print(ch);
        ++str;
    }
}

<span class="comment">// PROGRAM_PIC_VERSION command.</span>
<span class="keywordtype">void</span> cmdVersion(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    Serial.println(<span class="stringliteral">&quot;ProgramPIC 1.0&quot;</span>);
}

<span class="comment">// Initialize device properties from the &quot;devices&quot; list and</span>
<span class="comment">// print them to the serial port.  Note: &quot;dev&quot; is in PROGMEM.</span>
<span class="keywordtype">void</span> initDevice(<span class="keyword">const</span> <span class="keyword">struct</span> deviceInfo *dev)
{
    <span class="comment">// Update the global device details.</span>
    programEnd = pgm_read_dword(&amp;(dev-&gt;programSize)) - 1;
    configStart = pgm_read_dword(&amp;(dev-&gt;configStart));
    configEnd = configStart + pgm_read_word(&amp;(dev-&gt;configSize)) - 1;
    dataStart = pgm_read_dword(&amp;(dev-&gt;dataStart));
    dataEnd = dataStart + pgm_read_word(&amp;(dev-&gt;dataSize)) - 1;
    reservedStart = programEnd - pgm_read_word(&amp;(dev-&gt;reservedWords)) + 1;
    reservedEnd = programEnd;
    configSave = pgm_read_word(&amp;(dev-&gt;configSave));
    progFlashType = pgm_read_byte(&amp;(dev-&gt;progFlashType));
    dataFlashType = pgm_read_byte(&amp;(dev-&gt;dataFlashType));

    <span class="comment">// Print the extra device information.</span>
    Serial.print(<span class="stringliteral">&quot;DeviceName: &quot;</span>);
    printProgString((<span class="keyword">const</span> prog_char *)(pgm_read_word(&amp;(dev-&gt;name))));
    Serial.println();
    Serial.print(<span class="stringliteral">&quot;ProgramRange: 0000-&quot;</span>);
    printHex8(programEnd);
    Serial.println();
    Serial.print(<span class="stringliteral">&quot;ConfigRange: &quot;</span>);
    printHex8(configStart);
    Serial.print(<span class="charliteral">&#39;-&#39;</span>);
    printHex8(configEnd);
    Serial.println();
    <span class="keywordflow">if</span> (configSave != 0) {
        Serial.print(<span class="stringliteral">&quot;ConfigSave: &quot;</span>);
        printHex4(configSave);
        Serial.println();
    }
    Serial.print(<span class="stringliteral">&quot;DataRange: &quot;</span>);
    printHex8(dataStart);
    Serial.print(<span class="charliteral">&#39;-&#39;</span>);
    printHex8(dataEnd);
    Serial.println();
    <span class="keywordflow">if</span> (reservedStart &lt;= reservedEnd) {
        Serial.print(<span class="stringliteral">&quot;ReservedRange: &quot;</span>);
        printHex8(reservedStart);
        Serial.print(<span class="charliteral">&#39;-&#39;</span>);
        printHex8(reservedEnd);
        Serial.println();
    }
}

<span class="comment">// Offsets of interesting config locations that contain device information.</span>
<span class="preprocessor">#define DEV_USERID0         0</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEV_USERID1         1</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEV_USERID2         2</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEV_USERID3         3</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEV_ID              6</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEV_CONFIG_WORD     7</span>
<span class="preprocessor"></span>
<span class="comment">// DEVICE command.</span>
<span class="keywordtype">void</span> cmdDevice(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="comment">// Make sure the device is reset before we start.</span>
    exitProgramMode();

    <span class="comment">// Read identifiers and configuration words from config memory.</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> userid0 = readConfigWord(DEV_USERID0);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> userid1 = readConfigWord(DEV_USERID1);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> userid2 = readConfigWord(DEV_USERID2);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> userid3 = readConfigWord(DEV_USERID3);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deviceId = readConfigWord(DEV_ID);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> configWord = readConfigWord(DEV_CONFIG_WORD);

    <span class="comment">// If the device ID is all-zeroes or all-ones, then it could mean</span>
    <span class="comment">// one of the following:</span>
    <span class="comment">//</span>
    <span class="comment">// 1. There is no PIC in the programming socket.</span>
    <span class="comment">// 2. The VPP programming voltage is not available.</span>
    <span class="comment">// 3. Code protection is enabled and the PIC is unreadable.</span>
    <span class="comment">// 4. The PIC is an older model with no device identifier.</span>
    <span class="comment">//</span>
    <span class="comment">// Case 4 is the interesting one.  We look for any word in configuration</span>
    <span class="comment">// memory or the first 16 words of program memory that is non-zero.</span>
    <span class="comment">// If we find a non-zero word, we assume that we have a PIC but we</span>
    <span class="comment">// cannot detect what type it is.</span>
    <span class="keywordflow">if</span> (deviceId == 0 || deviceId == 0x3FFF) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word = userid0 | userid1 | userid2 | userid3 | configWord;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addr = 0;
        <span class="keywordflow">while</span> (!word &amp;&amp; addr &lt; 16) {
            word |= readWord(addr);
            ++addr;
        }
        <span class="keywordflow">if</span> (!word) {
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            exitProgramMode();
            <span class="keywordflow">return</span>;
        }
        deviceId = 0;
    }

    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);

    Serial.print(<span class="stringliteral">&quot;DeviceID: &quot;</span>);
    printHex4(deviceId);
    Serial.println();

    <span class="comment">// Find the device in the built-in list if we have details for it.</span>
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(devices[index].name)));
        <span class="keywordflow">if</span> (!name) {
            index = -1;
            <span class="keywordflow">break</span>;
        }
        <span class="keywordtype">int</span> <span class="keywordtype">id</span> = pgm_read_word(&amp;(devices[index].deviceId));
        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == (deviceId &amp; 0xFFE0))
            <span class="keywordflow">break</span>;
        ++index;
    }
    <span class="keywordflow">if</span> (index &gt;= 0) {
        initDevice(&amp;(devices[index]));
    } <span class="keywordflow">else</span> {
        <span class="comment">// Reset the global parameters to their defaults.  A separate</span>
        <span class="comment">// &quot;SETDEVICE&quot; command will be needed to set the correct values.</span>
        programEnd    = 0x07FF;
        configStart   = 0x2000;
        configEnd     = 0x2007;
        dataStart     = 0x2100;
        dataEnd       = 0x217F;
        reservedStart = 0x0800;
        reservedEnd   = 0x07FF;
        configSave    = 0x0000;
        progFlashType = FLASH4;
        dataFlashType = EEPROM;
    }

    Serial.print(<span class="stringliteral">&quot;ConfigWord: &quot;</span>);
    printHex4(configWord);
    Serial.println();

    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);

    <span class="comment">// Don&#39;t need programming mode once the details have been read.</span>
    exitProgramMode();
}

<span class="comment">// DEVICES command.</span>
<span class="keywordtype">void</span> cmdDevices(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(devices[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (index &gt; 0) {
            Serial.print(<span class="charliteral">&#39;,&#39;</span>);
            <span class="keywordflow">if</span> ((index % 6) == 0)
                Serial.println();
            <span class="keywordflow">else</span>
                Serial.print(<span class="charliteral">&#39; &#39;</span>);
        }
        printProgString(name);
        <span class="keywordtype">int</span> <span class="keywordtype">id</span> = (int)(pgm_read_word(&amp;(devices[index].deviceId)));
        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> != -1)
            Serial.print(<span class="charliteral">&#39;*&#39;</span>);
        ++index;
    }
    Serial.println();
    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// SETDEVICE command.</span>
<span class="keywordtype">void</span> cmdSetDevice(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="comment">// Extract the name of the device from the command arguments.</span>
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = args[len];
        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;\0&#39;</span> || ch == <span class="charliteral">&#39; &#39;</span> || ch == <span class="charliteral">&#39;\t&#39;</span>)
            <span class="keywordflow">break</span>;
        ++len;
    }

    <span class="comment">// Look for the name in the devices list.</span>
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(devices[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (matchString(name, args, len)) {
            Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
            initDevice(&amp;(devices[index]));
            Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
            exitProgramMode(); <span class="comment">// Force a reset upon the next command.</span>
            <span class="keywordflow">return</span>;
        }
        ++index;
    }
    Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
}

<span class="keywordtype">int</span> parseHex(<span class="keyword">const</span> <span class="keywordtype">char</span> *args, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *value)
{
    <span class="keywordtype">int</span> size = 0;
    *value = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = *args;
        <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;9&#39;</span>)
            *value = (*value &lt;&lt; 4) | (ch - <span class="charliteral">&#39;0&#39;</span>);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;A&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;F&#39;</span>)
            *value = (*value &lt;&lt; 4) | (ch - <span class="charliteral">&#39;A&#39;</span> + 10);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch &lt;= <span class="charliteral">&#39;f&#39;</span>)
            *value = (*value &lt;&lt; 4) | (ch - <span class="charliteral">&#39;a&#39;</span> + 10);
        <span class="keywordflow">else</span>
            <span class="keywordflow">break</span>;
        ++size;
        ++args;
    }
    <span class="keywordflow">if</span> (*args != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; *args != <span class="charliteral">&#39;-&#39;</span> &amp;&amp; *args != <span class="charliteral">&#39; &#39;</span> &amp;&amp; *args != <span class="charliteral">&#39;\t&#39;</span>)
        <span class="keywordflow">return</span> 0;
    <span class="keywordflow">return</span> size;
}

<span class="comment">// Parse a range of addresses of the form START or START-END.</span>
<span class="keywordtype">bool</span> parseRange(<span class="keyword">const</span> <span class="keywordtype">char</span> *args, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *start, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *end)
{
    <span class="keywordtype">int</span> size = parseHex(args, start);
    <span class="keywordflow">if</span> (!size)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    args += size;
    <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
        ++args;
    <span class="keywordflow">if</span> (*args != <span class="charliteral">&#39;-&#39;</span>) {
        *end = *start;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    ++args;
    <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
        ++args;
    <span class="keywordflow">if</span> (!parseHex(args, end))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">return</span> *end &gt;= *start;
}

<span class="keywordtype">bool</span> parseCheckedRange(<span class="keyword">const</span> <span class="keywordtype">char</span> *args, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *start, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *end)
{
    <span class="comment">// Parse the basic values and make sure that start &lt;= end.</span>
    <span class="keywordflow">if</span> (!parseRange(args, start, end))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    <span class="comment">// Check that both start and end are within the same memory area</span>
    <span class="comment">// and within the bounds of that memory area.</span>
    <span class="keywordflow">if</span> (*start &lt;= programEnd) {
        <span class="keywordflow">if</span> (*end &gt; programEnd)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*start &gt;= configStart &amp;&amp; *start &lt;= configEnd) {
        <span class="keywordflow">if</span> (*end &lt; configStart || *end &gt; configEnd)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*start &gt;= dataStart &amp;&amp; *start &lt;= dataEnd) {
        <span class="keywordflow">if</span> (*end &lt; dataStart || *end &gt; dataEnd)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
    } <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="comment">// READ command.</span>
<span class="keywordtype">void</span> cmdRead(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> start;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> end;
    <span class="keywordflow">if</span> (!parseCheckedRange(args, &amp;start, &amp;end)) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordflow">while</span> (start &lt;= end) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word = readWord(start);
        <span class="keywordflow">if</span> (count &gt; 0) {
            <span class="keywordflow">if</span> ((count % 8) == 0)
                Serial.println();
            <span class="keywordflow">else</span>
                Serial.print(<span class="charliteral">&#39; &#39;</span>);
        }
        printHex4(word);
        ++start;
        ++count;
        <span class="keywordflow">if</span> ((count % 32) == 0) {
            <span class="comment">// Toggle the activity LED to make it blink during long reads.</span>
            activity = !activity;
            <span class="keywordflow">if</span> (activity)
                digitalWrite(PIN_ACTIVITY, HIGH);
            <span class="keywordflow">else</span>
                digitalWrite(PIN_ACTIVITY, LOW);
        }
    }
    Serial.println();
    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// READBIN command.</span>
<span class="keywordtype">void</span> cmdReadBinary(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> start;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> end;
    <span class="keywordflow">if</span> (!parseCheckedRange(args, &amp;start, &amp;end)) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordtype">size_t</span> offset = 0;
    <span class="keywordflow">while</span> (start &lt;= end) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word = readWord(start);
        buffer[++offset] = (char)word;
        buffer[++offset] = (char)(word &gt;&gt; 8);
        <span class="keywordflow">if</span> (offset &gt;= BINARY_TRANSFER_MAX) {
            <span class="comment">// Buffer is full - flush it to the host.</span>
            buffer[0] = (char)offset;
            Serial.write((<span class="keyword">const</span> uint8_t *)buffer, offset + 1);
            offset = 0;
        }
        ++start;
        ++count;
        <span class="keywordflow">if</span> ((count % 64) == 0) {
            <span class="comment">// Toggle the activity LED to make it blink during long reads.</span>
            activity = !activity;
            <span class="keywordflow">if</span> (activity)
                digitalWrite(PIN_ACTIVITY, HIGH);
            <span class="keywordflow">else</span>
                digitalWrite(PIN_ACTIVITY, LOW);
        }
    }
    <span class="keywordflow">if</span> (offset &gt; 0) {
        <span class="comment">// Flush the final packet before the terminator.</span>
        buffer[0] = (char)offset;
        Serial.write((<span class="keyword">const</span> uint8_t *)buffer, offset + 1);
    }
    <span class="comment">// Write the terminator (a zero-length packet).</span>
    Serial.write((uint8_t)0x00);
}

<span class="keyword">const</span> <span class="keywordtype">char</span> s_force[] PROGMEM = <span class="stringliteral">&quot;FORCE&quot;</span>;

<span class="comment">// WRITE command.</span>
<span class="keywordtype">void</span> cmdWrite(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> limit;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;
    <span class="keywordtype">int</span> size;

    <span class="comment">// Was the &quot;FORCE&quot; option given?</span>
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">while</span> (args[len] != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; args[len] != <span class="charliteral">&#39; &#39;</span> &amp;&amp; args[len] != <span class="charliteral">&#39;\t&#39;</span>)
        ++len;
    <span class="keywordtype">bool</span> force = matchString(s_force, args, len);
    <span class="keywordflow">if</span> (force) {
        args += len;
        <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
            ++args;
    }

    size = parseHex(args, &amp;addr);
    <span class="keywordflow">if</span> (!size) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    args += size;
    <span class="keywordflow">if</span> (addr &lt;= programEnd) {
        limit = programEnd;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &gt;= configStart &amp;&amp; addr &lt;= configEnd) {
        limit = configEnd;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &gt;= dataStart &amp;&amp; addr &lt;= dataEnd) {
        limit = dataEnd;
    } <span class="keywordflow">else</span> {
        <span class="comment">// Address is not within one of the valid ranges.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
            ++args;
        <span class="keywordflow">if</span> (*args == <span class="charliteral">&#39;\0&#39;</span>)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (*args == <span class="charliteral">&#39;-&#39;</span>) {
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        size = parseHex(args, &amp;value);
        <span class="keywordflow">if</span> (!size) {
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        args += size;
        <span class="keywordflow">if</span> (addr &gt; limit) {
            <span class="comment">// We&#39;ve reached the limit of this memory area, so fail.</span>
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        <span class="keywordflow">if</span> (!force) {
            <span class="keywordflow">if</span> (!writeWord(addr, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)value)) {
                <span class="comment">// The actual write to the device failed.</span>
                Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                <span class="keywordflow">return</span>;
            }
        } <span class="keywordflow">else</span> {
            <span class="keywordflow">if</span> (!writeWordForced(addr, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)value)) {
                <span class="comment">// The actual write to the device failed.</span>
                Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                <span class="keywordflow">return</span>;
            }
        }
        ++addr;
        ++count;
    }
    <span class="keywordflow">if</span> (!count) {
        <span class="comment">// Missing word argument.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
    } <span class="keywordflow">else</span> {
        Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    }
}

<span class="comment">// Blocking serial read for use by WRITEBIN.</span>
<span class="keywordtype">int</span> readBlocking()
{
    <span class="keywordflow">while</span> (!Serial.available())
        ;   <span class="comment">// Do nothing.</span>
    <span class="keywordflow">return</span> Serial.read();
}

<span class="comment">// WRITEBIN command.</span>
<span class="keywordtype">void</span> cmdWriteBinary(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> limit;
    <span class="keywordtype">int</span> size;

    <span class="comment">// Was the &quot;FORCE&quot; option given?</span>
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">while</span> (args[len] != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; args[len] != <span class="charliteral">&#39; &#39;</span> &amp;&amp; args[len] != <span class="charliteral">&#39;\t&#39;</span>)
        ++len;
    <span class="keywordtype">bool</span> force = matchString(s_force, args, len);
    <span class="keywordflow">if</span> (force) {
        args += len;
        <span class="keywordflow">while</span> (*args == <span class="charliteral">&#39; &#39;</span> || *args == <span class="charliteral">&#39;\t&#39;</span>)
            ++args;
    }

    size = parseHex(args, &amp;addr);
    <span class="keywordflow">if</span> (!size) {
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    args += size;
    <span class="keywordflow">if</span> (addr &lt;= programEnd) {
        limit = programEnd;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &gt;= configStart &amp;&amp; addr &lt;= configEnd) {
        limit = configEnd;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &gt;= dataStart &amp;&amp; addr &lt;= dataEnd) {
        limit = dataEnd;
    } <span class="keywordflow">else</span> {
        <span class="comment">// Address is not within one of the valid ranges.</span>
        Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
        <span class="keywordflow">return</span>;
    }
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> count = 0;
    <span class="keywordtype">bool</span> activity = <span class="keyword">true</span>;
    <span class="keywordflow">for</span> (;;) {
        <span class="comment">// Read in the next binary packet.</span>
        <span class="keywordtype">int</span> len = readBlocking();
        <span class="keywordflow">while</span> (len == 0x0A &amp;&amp; count == 0) {
            <span class="comment">// Skip 0x0A bytes before the first packet as they are</span>
            <span class="comment">// probably part of a CRLF pair rather than a packet length.</span>
            len = readBlocking();
        }

        <span class="comment">// Stop if we have a zero packet length - end of upload.</span>
        <span class="keywordflow">if</span> (!len)
            <span class="keywordflow">break</span>;

        <span class="comment">// Read the contents of the packet from the serial input stream.</span>
        <span class="keywordtype">int</span> offset = 0;
        <span class="keywordflow">while</span> (offset &lt; len) {
            <span class="keywordflow">if</span> (offset &lt; BINARY_TRANSFER_MAX) {
                buffer[offset++] = (char)readBlocking();
            } <span class="keywordflow">else</span> {
                readBlocking();     <span class="comment">// Packet is too big - discard extra bytes.</span>
                ++offset;
            }
        }

        <span class="comment">// Write the words to memory.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> posn = 0; posn &lt; (len - 1); posn += 2) {
            <span class="keywordflow">if</span> (addr &gt; limit) {
                <span class="comment">// We&#39;ve reached the limit of this memory area, so fail.</span>
                Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                <span class="keywordflow">return</span>;
            }
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value =
                (((<span class="keywordtype">unsigned</span> int)buffer[posn]) &amp; 0xFF) |
                ((((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)buffer[posn + 1]) &amp; 0xFF) &lt;&lt; 8);
            <span class="keywordflow">if</span> (!force) {
                <span class="keywordflow">if</span> (!writeWord(addr, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)value)) {
                    <span class="comment">// The actual write to the device failed.</span>
                    Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                    <span class="keywordflow">return</span>;
                }
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">if</span> (!writeWordForced(addr, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)value)) {
                    <span class="comment">// The actual write to the device failed.</span>
                    Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
                    <span class="keywordflow">return</span>;
                }
            }
            ++addr;
            ++count;
            <span class="keywordflow">if</span> ((count % 24) == 0) {
                <span class="comment">// Toggle the activity LED to make it blink during long writes.</span>
                activity = !activity;
                <span class="keywordflow">if</span> (activity)
                    digitalWrite(PIN_ACTIVITY, HIGH);
                <span class="keywordflow">else</span>
                    digitalWrite(PIN_ACTIVITY, LOW);
            }
        }

        <span class="comment">// All words in this packet have been written successfully.</span>
        Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    }
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
}

<span class="keyword">const</span> <span class="keywordtype">char</span> s_noPreserve[] PROGMEM = <span class="stringliteral">&quot;NOPRESERVE&quot;</span>;

<span class="comment">// ERASE command.</span>
<span class="keywordtype">void</span> cmdErase(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    <span class="comment">// Was the &quot;NOPRESERVE&quot; option given?</span>
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">while</span> (args[len] != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; args[len] != <span class="charliteral">&#39; &#39;</span> &amp;&amp; args[len] != <span class="charliteral">&#39;\t&#39;</span>)
        ++len;
    <span class="keywordtype">bool</span> preserve = !matchString(s_noPreserve, args, len);

    <span class="comment">// Preserve reserved words if necessary.</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *reserved = 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> configWord = 0x3FFF;
    <span class="keywordflow">if</span> (preserve &amp;&amp; reservedStart &lt;= reservedEnd) {
        <span class="keywordtype">size_t</span> size = ((size_t)(reservedEnd - reservedStart + 1))
            * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
        reserved = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)malloc(size);
        <span class="keywordflow">if</span> (reserved) {
            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr = reservedStart;
            <span class="keywordtype">int</span> offset = 0;
            <span class="keywordflow">while</span> (addr &lt;= reservedEnd) {
                reserved[offset] = readWord(addr);
                ++addr;
                ++offset;
            }
        } <span class="keywordflow">else</span> {
            <span class="comment">// If we cannot preserve the reserved words, then abort now.</span>
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
    }
    <span class="keywordflow">if</span> (configSave != 0 &amp;&amp; preserve) {
        <span class="comment">// Some of the bits in the configuration word must also be saved.</span>
        configWord &amp;= ~configSave;
        configWord |= readWord(configStart + DEV_CONFIG_WORD) &amp; configSave;
    }

    <span class="comment">// Perform the memory type specific erase sequence.</span>
    <span class="keywordflow">switch</span> (progFlashType) {
    <span class="keywordflow">case</span> FLASH4:
        setErasePC();
        sendSimpleCommand(CMD_BULK_ERASE_PROGRAM);
        delayMicroseconds(DELAY_TERA);
        sendSimpleCommand(CMD_BULK_ERASE_DATA);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> FLASH5:
        setErasePC();
        sendSimpleCommand(CMD_CHIP_ERASE);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="comment">// Details for disabling code protection and erasing all memory</span>
        <span class="comment">// for PIC16F84/PIC16F84A comes from this doc, section 4.1:</span>
        <span class="comment">// http://ww1.microchip.com/downloads/en/DeviceDoc/30262e.pdf</span>
        setErasePC();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> count = 0; count &lt; 7; ++count)
            sendSimpleCommand(CMD_INCREMENT_ADDRESS); <span class="comment">// Advance to 0x2007</span>
        sendSimpleCommand(0x01);    <span class="comment">// Command 1</span>
        sendSimpleCommand(0x07);    <span class="comment">// Command 7</span>
        sendSimpleCommand(CMD_BEGIN_PROGRAM);
        delayMicroseconds(DELAY_TFULL84);
        sendSimpleCommand(0x01);    <span class="comment">// Command 1</span>
        sendSimpleCommand(0x07);    <span class="comment">// Command 7</span>

        <span class="comment">// Some FLASH devices need the data memory to be erased separately.</span>
        sendWriteCommand(CMD_LOAD_DATA_MEMORY, 0x3FFF);
        sendSimpleCommand(CMD_BULK_ERASE_DATA);
        sendSimpleCommand(CMD_BEGIN_PROGRAM);
        <span class="keywordflow">break</span>;
    }

    <span class="comment">// Wait until the chip is fully erased.</span>
    delayMicroseconds(DELAY_TFULLERA);

    <span class="comment">// Force the device to reset after it has been erased.</span>
    exitProgramMode();
    enterProgramMode();

    <span class="comment">// Write the reserved words back to program memory.</span>
    <span class="keywordflow">if</span> (reserved) {
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr = reservedStart;
        <span class="keywordtype">int</span> offset = 0;
        <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>;
        <span class="keywordflow">while</span> (addr &lt;= reservedEnd) {
            <span class="keywordflow">if</span> (!writeWord(addr, reserved[offset]))
                ok = <span class="keyword">false</span>;
            ++addr;
            ++offset;
        }
        free(reserved);
        <span class="keywordflow">if</span> (!ok) {
            <span class="comment">// Reserved words did not read back correctly.</span>
            Serial.println(<span class="stringliteral">&quot;ERROR&quot;</span>);
            <span class="keywordflow">return</span>;
        }
    }

    <span class="comment">// Forcibly write 0x3FFF over the configuration words as erase</span>
    <span class="comment">// sometimes won&#39;t reset the words (e.g. PIC16F628A).  If the</span>
    <span class="comment">// write fails, then leave the words as-is - don&#39;t report the failure.</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> configAddr = configStart + DEV_CONFIG_WORD;
            configAddr &lt;= configEnd; ++configAddr)
        writeWordForced(configAddr, configWord);

    <span class="comment">// Done.</span>
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
}

<span class="comment">// PWROFF command.</span>
<span class="keywordtype">void</span> cmdPowerOff(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    exitProgramMode();
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
}

<span class="comment">// List of all commands that are understood by the programmer.</span>
<span class="keyword">typedef</span> void (*commandFunc)(<span class="keyword">const</span> <span class="keywordtype">char</span> *args);
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <span class="keyword">const</span> prog_char *name;
    commandFunc func;
    <span class="keyword">const</span> prog_char *desc;
    <span class="keyword">const</span> prog_char *args;
} command_t;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdRead[] PROGMEM = <span class="stringliteral">&quot;READ&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadDesc[] PROGMEM =
    <span class="stringliteral">&quot;Reads program and data words from device memory (text)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadArgs[] PROGMEM = <span class="stringliteral">&quot;STARTADDR[-ENDADDR]&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadBinary[] PROGMEM = <span class="stringliteral">&quot;READBIN&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdReadBinaryDesc[] PROGMEM =
    <span class="stringliteral">&quot;Reads program and data words from device memory (binary)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWrite[] PROGMEM = <span class="stringliteral">&quot;WRITE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteDesc[] PROGMEM =
    <span class="stringliteral">&quot;Writes program and data words to device memory (text)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteArgs[] PROGMEM = <span class="stringliteral">&quot;STARTADDR WORD [WORD ...]&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteBinary[] PROGMEM = <span class="stringliteral">&quot;WRITEBIN&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteBinaryDesc[] PROGMEM =
    <span class="stringliteral">&quot;Writes program and data words to device memory (binary)&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdWriteBinaryArgs[] PROGMEM = <span class="stringliteral">&quot;STARTADDR&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdErase[] PROGMEM = <span class="stringliteral">&quot;ERASE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdEraseDesc[] PROGMEM =
    <span class="stringliteral">&quot;Erases the contents of program, configuration, and data memory&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDevice[] PROGMEM = <span class="stringliteral">&quot;DEVICE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDeviceDesc[] PROGMEM =
    <span class="stringliteral">&quot;Probes the device and returns information about it&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDevices[] PROGMEM = <span class="stringliteral">&quot;DEVICES&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdDevicesDesc[] PROGMEM =
    <span class="stringliteral">&quot;Returns a list of all supported device types&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdSetDevice[] PROGMEM = <span class="stringliteral">&quot;SETDEVICE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdSetDeviceDesc[] PROGMEM =
    <span class="stringliteral">&quot;Sets a specific device type manually&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdSetDeviceArgs[] PROGMEM = <span class="stringliteral">&quot;DEVTYPE&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdPowerOff[] PROGMEM = <span class="stringliteral">&quot;PWROFF&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdPowerOffDesc[] PROGMEM =
    <span class="stringliteral">&quot;Powers off the device in the programming socket&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdVersion[] PROGMEM = <span class="stringliteral">&quot;PROGRAM_PIC_VERSION&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdVersionDesc[] PROGMEM =
    <span class="stringliteral">&quot;Prints the version of ProgramPIC&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdHelp[] PROGMEM = <span class="stringliteral">&quot;HELP&quot;</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> s_cmdHelpDesc[] PROGMEM =
    <span class="stringliteral">&quot;Prints this help message&quot;</span>;
<span class="keyword">const</span> command_t commands[] PROGMEM = {
    {s_cmdRead, cmdRead, s_cmdReadDesc, s_cmdReadArgs},
    {s_cmdReadBinary, cmdReadBinary, s_cmdReadBinaryDesc, s_cmdReadArgs},
    {s_cmdWrite, cmdWrite, s_cmdWriteDesc, s_cmdWriteArgs},
    {s_cmdWriteBinary, cmdWriteBinary, s_cmdWriteBinaryDesc, s_cmdWriteBinaryArgs},
    {s_cmdErase, cmdErase, s_cmdEraseDesc, 0},
    {s_cmdDevice, cmdDevice, s_cmdDeviceDesc, 0},
    {s_cmdDevices, cmdDevices, s_cmdDevicesDesc, 0},
    {s_cmdSetDevice, cmdSetDevice, s_cmdSetDeviceDesc, s_cmdSetDeviceArgs},
    {s_cmdPowerOff, cmdPowerOff, s_cmdPowerOffDesc, 0},
    {s_cmdVersion, cmdVersion, s_cmdVersionDesc, 0},
    {s_cmdHelp, cmdHelp, s_cmdHelpDesc, 0},
    {0, 0}
};

<span class="comment">// &quot;HELP&quot; command.</span>
<span class="keywordtype">void</span> cmdHelp(<span class="keyword">const</span> <span class="keywordtype">char</span> *args)
{
    Serial.println(<span class="stringliteral">&quot;OK&quot;</span>);
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keyword">const</span> prog_char *desc = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].desc)));
        <span class="keyword">const</span> prog_char *args = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].args)));
        printProgString(name);
        <span class="keywordflow">if</span> (args) {
            Serial.print(<span class="charliteral">&#39; &#39;</span>);
            printProgString(args);
        }
        Serial.println();
        Serial.print(<span class="stringliteral">&quot;    &quot;</span>);
        printProgString(desc);
        Serial.println();
        ++index;
    }
    Serial.println(<span class="stringliteral">&quot;.&quot;</span>);
}

<span class="comment">// Match a data-space string where the name comes from PROGMEM.</span>
<span class="keywordtype">bool</span> matchString(<span class="keyword">const</span> prog_char *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len)
{
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch1 = (char)(pgm_read_byte(name));
        <span class="keywordflow">if</span> (ch1 == <span class="charliteral">&#39;\0&#39;</span>)
            <span class="keywordflow">return</span> len == 0;
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len == 0)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (ch1 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch1 &lt;= <span class="charliteral">&#39;z&#39;</span>)
            ch1 = ch1 - <span class="charliteral">&#39;a&#39;</span> + <span class="charliteral">&#39;A&#39;</span>;
        <span class="keywordtype">char</span> ch2 = *str;
        <span class="keywordflow">if</span> (ch2 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; ch2 &lt;= <span class="charliteral">&#39;z&#39;</span>)
            ch2 = ch2 - <span class="charliteral">&#39;a&#39;</span> + <span class="charliteral">&#39;A&#39;</span>;
        <span class="keywordflow">if</span> (ch1 != ch2)
            <span class="keywordflow">break</span>;
        ++name;
        ++str;
        --len;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}

<span class="comment">// Process commands from the host.</span>
<span class="keywordtype">void</span> processCommand(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf)
{
    <span class="comment">// Skip white space at the start of the command.</span>
    <span class="keywordflow">while</span> (*buf == <span class="charliteral">&#39; &#39;</span> || *buf == <span class="charliteral">&#39;\t&#39;</span>)
        ++buf;
    <span class="keywordflow">if</span> (*buf == <span class="charliteral">&#39;\0&#39;</span>)
        <span class="keywordflow">return</span>;     <span class="comment">// Ignore blank lines.</span>

    <span class="comment">// Extract the command portion of the line.</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span> *cmd = buf;
    <span class="keywordtype">int</span> len = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordtype">char</span> ch = *buf;
        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;\0&#39;</span> || ch == <span class="charliteral">&#39; &#39;</span> || ch == <span class="charliteral">&#39;\t&#39;</span>)
            <span class="keywordflow">break</span>;
        ++buf;
        ++len;
    }

    <span class="comment">// Skip white space after the command name and before the arguments.</span>
    <span class="keywordflow">while</span> (*buf == <span class="charliteral">&#39; &#39;</span> || *buf == <span class="charliteral">&#39;\t&#39;</span>)
        ++buf;

    <span class="comment">// Find the command and execute it.</span>
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (;;) {
        <span class="keyword">const</span> prog_char *name = (<span class="keyword">const</span> prog_char *)
            (pgm_read_word(&amp;(commands[index].name)));
        <span class="keywordflow">if</span> (!name)
            <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (matchString(name, cmd, len)) {
            commandFunc func =
                (commandFunc)(pgm_read_word(&amp;(commands[index].func)));
            (*func)(buf);
            <span class="keywordflow">return</span>;
        }
        ++index;
    }

    <span class="comment">// Unknown command.</span>
    Serial.println(<span class="stringliteral">&quot;NOTSUPPORTED&quot;</span>);
}

<span class="comment">// Enter high voltage programming mode.</span>
<span class="keywordtype">void</span> enterProgramMode()
{
    <span class="comment">// Bail out if already in programming mode.</span>
    <span class="keywordflow">if</span> (state != STATE_IDLE)
        <span class="keywordflow">return</span>;

    <span class="comment">// Lower MCLR, VDD, DATA, and CLOCK initially.  This will put the</span>
    <span class="comment">// PIC into the powered-off, reset state just in case.</span>
    digitalWrite(PIN_MCLR, MCLR_RESET);
    digitalWrite(PIN_VDD, LOW);
    digitalWrite(PIN_DATA, LOW);
    digitalWrite(PIN_CLOCK, LOW);

    <span class="comment">// Wait for the lines to settle.</span>
    delayMicroseconds(DELAY_SETTLE);

    <span class="comment">// Switch DATA and CLOCK into outputs.</span>
    pinMode(PIN_DATA, OUTPUT);
    pinMode(PIN_CLOCK, OUTPUT);

    <span class="comment">// Raise MCLR, then VDD.</span>
    digitalWrite(PIN_MCLR, MCLR_VPP);
    delayMicroseconds(DELAY_TPPDP);
    digitalWrite(PIN_VDD, HIGH);
    delayMicroseconds(DELAY_THLD0);

    <span class="comment">// Now in program mode, starting at the first word of program memory.</span>
    state = STATE_PROGRAM;
    pc = 0;
}

<span class="comment">// Exit programming mode and reset the device.</span>
<span class="keywordtype">void</span> exitProgramMode()
{
    <span class="comment">// Nothing to do if already out of programming mode.</span>
    <span class="keywordflow">if</span> (state == STATE_IDLE)
        <span class="keywordflow">return</span>;

    <span class="comment">// Lower MCLR, VDD, DATA, and CLOCK.</span>
    digitalWrite(PIN_MCLR, MCLR_RESET);
    digitalWrite(PIN_VDD, LOW);
    digitalWrite(PIN_DATA, LOW);
    digitalWrite(PIN_CLOCK, LOW);

    <span class="comment">// Float the DATA and CLOCK pins.</span>
    pinMode(PIN_DATA, INPUT);
    pinMode(PIN_CLOCK, INPUT);

    <span class="comment">// Now in the idle state with the PIC powered off.</span>
    state = STATE_IDLE;
    pc = 0;
}

<span class="comment">// Send a command to the PIC.</span>
<span class="keywordtype">void</span> sendCommand(byte cmd)
{
    <span class="keywordflow">for</span> (byte bit = 0; bit &lt; 6; ++bit) {
        digitalWrite(PIN_CLOCK, HIGH);
        <span class="keywordflow">if</span> (cmd &amp; 1)
            digitalWrite(PIN_DATA, HIGH);
        <span class="keywordflow">else</span>
            digitalWrite(PIN_DATA, LOW);
        delayMicroseconds(DELAY_TSET1);
        digitalWrite(PIN_CLOCK, LOW);
        delayMicroseconds(DELAY_THLD1);
        cmd &gt;&gt;= 1;
    }
}

<span class="comment">// Send a command to the PIC that has no arguments.</span>
<span class="keywordtype">void</span> sendSimpleCommand(byte cmd)
{
    sendCommand(cmd);
    delayMicroseconds(DELAY_TDLY2);
}

<span class="comment">// Send a command to the PIC that writes a data argument.</span>
<span class="keywordtype">void</span> sendWriteCommand(byte cmd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data)
{
    sendCommand(cmd);
    delayMicroseconds(DELAY_TDLY2);
    <span class="keywordflow">for</span> (byte bit = 0; bit &lt; 16; ++bit) {
        digitalWrite(PIN_CLOCK, HIGH);
        <span class="keywordflow">if</span> (data &amp; 1)
            digitalWrite(PIN_DATA, HIGH);
        <span class="keywordflow">else</span>
            digitalWrite(PIN_DATA, LOW);
        delayMicroseconds(DELAY_TSET1);
        digitalWrite(PIN_CLOCK, LOW);
        delayMicroseconds(DELAY_THLD1);
        data &gt;&gt;= 1;
    }
    delayMicroseconds(DELAY_TDLY2);
}

<span class="comment">// Send a command to the PIC that reads back a data value.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sendReadCommand(byte cmd)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data = 0;
    sendCommand(cmd);
    digitalWrite(PIN_DATA, LOW);
    pinMode(PIN_DATA, INPUT);
    delayMicroseconds(DELAY_TDLY2);
    <span class="keywordflow">for</span> (byte bit = 0; bit &lt; 16; ++bit) {
        data &gt;&gt;= 1;
        digitalWrite(PIN_CLOCK, HIGH);
        delayMicroseconds(DELAY_TDLY3);
        <span class="keywordflow">if</span> (digitalRead(PIN_DATA))
            data |= 0x8000;
        digitalWrite(PIN_CLOCK, LOW);
        delayMicroseconds(DELAY_THLD1);
    }
    pinMode(PIN_DATA, OUTPUT);
    delayMicroseconds(DELAY_TDLY2);
    <span class="keywordflow">return</span> data;
}

<span class="comment">// Set the program counter to a specific &quot;flat&quot; address.</span>
<span class="keywordtype">void</span> setPC(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr)
{
    <span class="keywordflow">if</span> (addr &gt;= dataStart &amp;&amp; addr &lt;= dataEnd) {
        <span class="comment">// Data memory.</span>
        addr -= dataStart;
        <span class="keywordflow">if</span> (state != STATE_PROGRAM || addr &lt; pc) {
            <span class="comment">// Device is off, currently looking at configuration memory,</span>
            <span class="comment">// or the address is further back.  Reset the device.</span>
            exitProgramMode();
            enterProgramMode();
        }
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &gt;= configStart &amp;&amp; addr &lt;= configEnd) {
        <span class="comment">// Configuration memory.</span>
        addr -= configStart;
        <span class="keywordflow">if</span> (state == STATE_IDLE) {
            <span class="comment">// Enter programming mode and switch to config memory.</span>
            enterProgramMode();
            sendWriteCommand(CMD_LOAD_CONFIG, 0);
            state = STATE_CONFIG;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state == STATE_PROGRAM) {
            <span class="comment">// Switch from program memory to config memory.</span>
            sendWriteCommand(CMD_LOAD_CONFIG, 0);
            state = STATE_CONFIG;
            pc = 0;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &lt; pc) {
            <span class="comment">// Need to go backwards in config memory, so reset the device.</span>
            exitProgramMode();
            enterProgramMode();
            sendWriteCommand(CMD_LOAD_CONFIG, 0);
            state = STATE_CONFIG;
        }
    } <span class="keywordflow">else</span> {
        <span class="comment">// Program memory.</span>
        <span class="keywordflow">if</span> (state != STATE_PROGRAM || addr &lt; pc) {
            <span class="comment">// Device is off, currently looking at configuration memory,</span>
            <span class="comment">// or the address is further back.  Reset the device.</span>
            exitProgramMode();
            enterProgramMode();
        }
    }
    <span class="keywordflow">while</span> (pc &lt; addr) {
        sendSimpleCommand(CMD_INCREMENT_ADDRESS);
        ++pc;
    }
}

<span class="comment">// Sets the PC for &quot;erase mode&quot;, which is activated by loading the</span>
<span class="comment">// data value 0x3FFF into location 0 of configuration memory.</span>
<span class="keywordtype">void</span> setErasePC()
{
    <span class="comment">// Forcibly reset the device so we know what state it is in.</span>
    exitProgramMode();
    enterProgramMode();

    <span class="comment">// Load 0x3FFF for the configuration.</span>
    sendWriteCommand(CMD_LOAD_CONFIG, 0x3FFF);
    state = STATE_CONFIG;
}

<span class="comment">// Read a word from memory (program, config, or data depending upon addr).</span>
<span class="comment">// The start and stop bits will be stripped from the raw value from the PIC.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> readWord(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr)
{
    setPC(addr);
    <span class="keywordflow">if</span> (addr &gt;= dataStart &amp;&amp; addr &lt;= dataEnd)
        <span class="keywordflow">return</span> (sendReadCommand(CMD_READ_DATA_MEMORY) &gt;&gt; 1) &amp; 0x00FF;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> (sendReadCommand(CMD_READ_PROGRAM_MEMORY) &gt;&gt; 1) &amp; 0x3FFF;
}

<span class="comment">// Read a word from config memory using relative, non-flat, addressing.</span>
<span class="comment">// Used by the &quot;DEVICE&quot; command to fetch information about devices whose</span>
<span class="comment">// flat address ranges are presently unknown.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> readConfigWord(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr)
{
    <span class="keywordflow">if</span> (state == STATE_IDLE) {
        <span class="comment">// Enter programming mode and switch to config memory.</span>
        enterProgramMode();
        sendWriteCommand(CMD_LOAD_CONFIG, 0);
        state = STATE_CONFIG;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state == STATE_PROGRAM) {
        <span class="comment">// Switch from program memory to config memory.</span>
        sendWriteCommand(CMD_LOAD_CONFIG, 0);
        state = STATE_CONFIG;
        pc = 0;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr &lt; pc) {
        <span class="comment">// Need to go backwards in config memory, so reset the device.</span>
        exitProgramMode();
        enterProgramMode();
        sendWriteCommand(CMD_LOAD_CONFIG, 0);
        state = STATE_CONFIG;
    }
    <span class="keywordflow">while</span> (pc &lt; addr) {
        sendSimpleCommand(CMD_INCREMENT_ADDRESS);
        ++pc;
    }
    <span class="keywordflow">return</span> (sendReadCommand(CMD_READ_PROGRAM_MEMORY) &gt;&gt; 1) &amp; 0x3FFF;
}

<span class="comment">// Begin a programming cycle, depending upon the type of flash being written.</span>
<span class="keywordtype">void</span> beginProgramCycle(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr, <span class="keywordtype">bool</span> isData)
{
    <span class="keywordflow">switch</span> (isData ? dataFlashType : progFlashType) {
    <span class="keywordflow">case</span> FLASH:
    <span class="keywordflow">case</span> EEPROM:
        sendSimpleCommand(CMD_BEGIN_PROGRAM);
        delayMicroseconds(DELAY_TDPROG + DELAY_TERA);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> FLASH4:
        sendSimpleCommand(CMD_BEGIN_PROGRAM);
        delayMicroseconds(DELAY_TPROG);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> FLASH5:
        sendSimpleCommand(CMD_BEGIN_PROGRAM_ONLY);
        delayMicroseconds(DELAY_TPROG5);
        sendSimpleCommand(CMD_END_PROGRAM_ONLY);
        <span class="keywordflow">break</span>;
    }
}

<span class="comment">// Write a word to memory (program, config, or data depending upon addr).</span>
<span class="comment">// Returns true if the write succeeded, false if read-back failed to match.</span>
<span class="keywordtype">bool</span> writeWord(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> readBack;
    setPC(addr);
    <span class="keywordflow">if</span> (addr &gt;= dataStart &amp;&amp; addr &lt;= dataEnd) {
        word &amp;= 0x00FF;
        sendWriteCommand(CMD_LOAD_DATA_MEMORY, word &lt;&lt; 1);
        beginProgramCycle(addr, <span class="keyword">true</span>);
        readBack = sendReadCommand(CMD_READ_DATA_MEMORY);
        readBack = (readBack &gt;&gt; 1) &amp; 0x00FF;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!configSave || addr != (configStart + DEV_CONFIG_WORD)) {
        word &amp;= 0x3FFF;
        sendWriteCommand(CMD_LOAD_PROGRAM_MEMORY, word &lt;&lt; 1);
        beginProgramCycle(addr, <span class="keyword">false</span>);
        readBack = sendReadCommand(CMD_READ_PROGRAM_MEMORY);
        readBack = (readBack &gt;&gt; 1) &amp; 0x3FFF;
    } <span class="keywordflow">else</span> {
        <span class="comment">// The configuration word has calibration bits within it that</span>
        <span class="comment">// must be preserved when we write to it.  Read the current value</span>
        <span class="comment">// and preserve the necessary bits.</span>
        readBack = (sendReadCommand(CMD_READ_PROGRAM_MEMORY) &gt;&gt; 1) &amp; 0x3FFF;
        word = (readBack &amp; configSave) | (word &amp; 0x3FFF &amp; ~configSave);
        sendWriteCommand(CMD_LOAD_PROGRAM_MEMORY, word &lt;&lt; 1);
        beginProgramCycle(addr, <span class="keyword">false</span>);
        readBack = sendReadCommand(CMD_READ_PROGRAM_MEMORY);
        readBack = (readBack &gt;&gt; 1) &amp; 0x3FFF;
    }
    <span class="keywordflow">return</span> readBack == word;
}

<span class="comment">// Force a word to be written even if it normally would protect config bits.</span>
<span class="keywordtype">bool</span> writeWordForced(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> word)
{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> readBack;
    setPC(addr);
    <span class="keywordflow">if</span> (addr &gt;= dataStart &amp;&amp; addr &lt;= dataEnd) {
        word &amp;= 0x00FF;
        sendWriteCommand(CMD_LOAD_DATA_MEMORY, word &lt;&lt; 1);
        beginProgramCycle(addr, <span class="keyword">true</span>);
        readBack = sendReadCommand(CMD_READ_DATA_MEMORY);
        readBack = (readBack &gt;&gt; 1) &amp; 0x00FF;
    } <span class="keywordflow">else</span> {
        word &amp;= 0x3FFF;
        sendWriteCommand(CMD_LOAD_PROGRAM_MEMORY, word &lt;&lt; 1);
        beginProgramCycle(addr, <span class="keyword">false</span>);
        readBack = sendReadCommand(CMD_READ_PROGRAM_MEMORY);
        readBack = (readBack &gt;&gt; 1) &amp; 0x3FFF;
    }
    <span class="keywordflow">return</span> readBack == word;
}
</pre></div> </div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 7 2012 15:08:57 for Ardpicprog by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
